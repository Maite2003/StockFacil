# StockFacil - Complete Project Documentation

## General Project Information

### Description
**StockFacil** is a comprehensive web application for inventory, customer and supplier management for businesses. It allows companies to maintain complete control over their stock, prices, commercial relationships and product structure with variants.

### Application Type
- **Frontend**: Web Application
- **Backend**: REST API 
- **Database**: PostgreSQL with Prisma ORM

### Current Development Status
âœ… **Completed**:
- Database schema defined
- Prisma schema configured
- CRUD routes implemented for:
  - Users
  - Customers
  - Suppliers
  - Categories
  - Products
  - Product variants
  - **Variant-Suppliers** (variant-supplier relationship):
    - `GET /suppliers/:supplierId/variants` - Get variants from a supplier
    - `POST /variant-suppliers/` - Create variant-supplier relationship
    - `GET /variant-suppliers/:id` - Get specific relationship
    - `PATCH /variant-suppliers/:id` - Update price/primary supplier
    - `DELETE /variant-suppliers/:id` - Delete relationship
- Validations with express-validator implemented
- **JWT Authentication implemented**:
  - Login and register (public routes)
  - **ðŸ†• Email verification system with Nodemailer OAuth2**:
    - `POST /auth/send-verification` - Send/resend verification email
    - `GET /auth/verify-email/:token` - Verify email with token
    - `GET /auth/verification-status` - Check verification status
    - Email verification tokens with 24-hour expiration
    - **Gmail OAuth2 integration** with Nodemailer (completely free, production-ready)
    - HTML email templates with verification links
    - Express 5 compatible implementation
    - Graceful error handling when email service is not configured
  - All other routes require authentication (including user update)
  - Authorization middleware configured
  - Automatic user_id extraction from token
- **Optimized query for findAll products**:
  - Raw SQL with performance optimization for listings
  - Consistent format with findById
  - JSON aggregation for variants
  - Explicit casting to avoid BigInt serialization errors
- **Unified response format**:
  - Automatic Decimal to Number conversion in responses
  - Swagger schema updated with 'number' type for prices
  - Total consistency between findAll and findById
- **ðŸ†• Advanced Pagination System**:
  - Complete pagination with metadata (currentPage, totalPages, totalItems, etc.)
  - Search functionality across relevant fields
  - Flexible sorting (sortBy field, sortOrder asc/desc)
  - Query parameters: page, limit, search, sortBy, sortOrder
  - Implemented in GET /products, /customers, /suppliers, /variants endpoints
  - Maximum 100 items per page for performance
- **ðŸ†• API Documentation with Swagger**:
  - Complete schemas defined (Product, ProductVariant, Agenda, Category, User, VariantSupplier, Error)
  - **New Pagination Schemas**:
    - `Pagination` - Complete pagination metadata with 10 fields
    - `PaginatedProductsResponse` - Products with pagination
    - `PaginatedCustomersResponse` - Customers with pagination  
    - `PaginatedSuppliersResponse` - Suppliers with pagination
    - `PaginatedVariantsResponse` - Variants with pagination
  - **New Query Parameters**:
    - `PageParam` - Page number (1-based, default 1)
    - `LimitParam` - Items per page (1-100, default 10)
    - `SearchParam` - Search term filter
    - `SortByParam` - Field to sort by
    - `SortOrderParam` - Sort direction (asc/desc)
  - **Products CRUD endpoints documentation completed** âœ…:
    - âœ… `POST /products` - Create new product (completed with specific response format)
    - âœ… `GET /products` - Get all products **with pagination, search & sorting** (completed with {products, pagination} format)
    - âœ… `GET /products/:id` - Get product by ID (completed with {product} format)
    - âœ… `PATCH /products/:id` - Update product (completed with {product} format)
    - âœ… `DELETE /products/:id` - Delete product (completed with 204 no content)
  - **Product Variants CRUD endpoints documentation completed** âœ…:
    - âœ… `GET /products/:productId/variants` - Get all variants **with pagination, search & sorting** (with {variants, pagination} format)
    - âœ… `POST /products/:productId/variants` - Create new variant (with {variant} format)
    - âœ… `GET /products/:productId/variants/:id` - Get variant by ID (with {variant} format)
    - âœ… `PATCH /products/:productId/variants/:id` - Update variant (with {variant} format)
    - âœ… `DELETE /products/:productId/variants/:id` - Delete variant (204 no content)
  - **Categories CRUD endpoints documentation completed** âœ…:
    - âœ… `GET /categories` - Get all categories (with {categories, length} format)
    - âœ… `POST /categories` - Create new category (with {Category} format)
    - âœ… `GET /categories/:id` - Get category by ID (with {category} format)
    - âœ… `PATCH /categories/:id` - Update category (with {category} format)
    - âœ… `DELETE /categories/:id` - Delete category (204 no content)
  - **Customers CRUD endpoints documentation completed** âœ…:
    - âœ… `GET /customers` - Get all customers **with pagination, search & sorting** (with {customers, pagination} format)
    - âœ… `POST /customers` - Create new customer (with {Customer} format)
    - âœ… `GET /customers/:id` - Get customer by ID (with {customer} format)
    - âœ… `PATCH /customers/:id` - Update customer (with {customer} format)
    - âœ… `DELETE /customers/:id` - Delete customer (204 no content)
  - **Suppliers CRUD endpoints documentation completed** âœ…:
    - âœ… `GET /suppliers` - Get all suppliers **with pagination, search & sorting** (with {suppliers, pagination} format)
    - âœ… `POST /suppliers` - Create new supplier (with {Supplier} format)
    - âœ… `GET /suppliers/:id` - Get supplier by ID (with {supplier} format)
    - âœ… `PATCH /suppliers/:id` - Update supplier (with {supplier} format)
    - âœ… `DELETE /suppliers/:id` - Delete supplier (204 no content)
    - **Note**: Uses "Authentication Invalid" message for 401 errors (different from other endpoints)
  - **Authentication endpoints documentation completed** âœ…:
    - âœ… `POST /auth/register` - Register new user (with {user, token} format)
    - âœ… `POST /auth/login` - User login (with {user, token} format)
    - âœ… `PATCH /auth/profile` - Update user profile (with {user} format)
    - âœ… `DELETE /auth/profile` - Delete user account (204 no content)
    - **ðŸ†• Email Verification Endpoints - Fully Documented with Swagger** âœ…:
      - âœ… `POST /auth/send-verification` - Send/resend email verification **with detailed Swagger documentation**:
        - **Authentication**: Required (JWT Bearer token)
        - **Request Body**: No body required
        - **Success Response (204)**: No Content - Verification email sent successfully
        - **Error Responses**: 401 (Unauthorized), 409 (Already verified), 500 (Email service error)
        - **Description**: Generates JWT token with 24h expiration, sends HTML email with verification link using Nodemailer OAuth2
        - **Email Content**: Professional HTML template with StockFacil branding and verification button
        - **Graceful Handling**: Returns success even if email service is misconfigured (logs error internally)
        - **HTTP Semantics**: Uses 204 No Content as no data needs to be returned after successful email send
      - âœ… `GET /auth/verify-email/:token` - Verify email with token **with detailed Swagger documentation**:
        - **Authentication**: None required (public endpoint)
        - **Path Parameter**: `token` (JWT token from email link)
        - **Success Response (204)**: No Content - Email verified successfully
        - **Error Responses**: 400 (Invalid/expired token), 404 (User not found), 500 (Server error)
        - **Description**: Validates JWT token, updates user's email_verified to true, clears verification token from database
        - **Token Validation**: Checks token purpose, expiration, and user existence
        - **Security**: Single-use token (cleared after successful verification)
        - **HTTP Semantics**: Uses 204 No Content as verification action is complete without data to return
      - âœ… `GET /auth/verification-status` - Check email verification status **with detailed Swagger documentation**:
        - **Authentication**: Required (JWT Bearer token)
        - **Request Body**: No body required  
        - **Success Response (200)**: `{email_verified: boolean, email: "user@example.com"}`
        - **Error Responses**: 401 (Unauthorized), 500 (Server error)
        - **Description**: Returns current email verification status for authenticated user
        - **Usage**: Frontend uses this to show verification prompts and update UI state
        - **Real-time Status**: Always reflects current database state
        - **HTTP Semantics**: Uses 200 OK as it returns useful data (verification status and email)
  - Response format: Success returns appropriate object structure, errors return `{msg: <message>}`
  - All protected endpoints include JWT authentication requirement

âœ… **All development completed**:
- **Variant-Suppliers CRUD endpoints documentation completed** âœ…:
  - âœ… `GET /suppliers/:supplierId/variants` - Get variants for a supplier (for purchasing workflow)
  - âœ… `POST /variant-suppliers/` - Create variant-supplier relationship
  - âœ… `GET /variant-suppliers/:id` - Get specific relationship
  - âœ… `PATCH /variant-suppliers/:id` - Update price/primary supplier status
  - âœ… `DELETE /variant-suppliers/:id` - Delete relationship
- **ðŸ†• Statistics endpoints completed** âœ…:
  - âœ… `GET /stats/inventory` - Get inventory statistics (totalProducts, lowStockAlerts, outOfStockItems)
  - âœ… `GET /stats/agenda` - Get agenda statistics (totalCustomers, totalSuppliers)
- **ðŸ†• Utility endpoints completed** âœ…:
  - âœ… `GET /` - Root endpoint with API information and docs link
  - âœ… `GET /health` - Health check endpoint with status and environment info
- **ðŸ†• Dynamic Swagger Configuration**:
  - âœ… **Server URLs**: Automatically configured based on NODE_ENV (localhost for development, production URL for production)
  - âœ… **Express 5 Compatibility**: Modern implementation with Nodemailer OAuth2
- **ðŸ†• Production Security implemented** âœ…:
  - âœ… **Helmet**: Security headers (XSS, clickjacking, MIME sniffing protection)
  - âœ… **Rate Limiting**: 5 requests/15min for auth, 100 requests/15min for API endpoints
  - âœ… **CORS**: Properly configured for production and development environments
  - âœ… **Input Sanitization**: HTTP parameter pollution prevention (express-mongo-sanitize removed for Express 5 compatibility)
  - âœ… **Environment-based configuration**: Different security settings and **dynamic servers configuration** for production vs development
  - âœ… **Deployed on Render**: https://stockfacil.onrender.com/
  - âœ… **API Documentation**: https://stockfacil.onrender.com/api-docs
  - âœ… **Environment configured**: NODE_ENV=production, PostgreSQL, JWT authentication, **Nodemailer OAuth2**
  - âœ… **Multi-tenant security**: All endpoints properly isolated per user
  - âœ… **Performance optimized**: Raw SQL for stats, pagination limits, database indexing

## Multi-Tenant Architecture

### Fundamental Principle
**ALL tables (except `users`) include `user_id` as foreign key** to ensure each tenant (user) can only access their own data.

### Multi-Tenant Security Implementation
```sql
-- Example of secure query that always includes user_id
SELECT * FROM products WHERE user_id = :current_user_id AND id = :product_id;

-- Relationships also respect the tenant
SELECT p.*, c.name as category_name 
FROM products p 
JOIN categories c ON c.id = p.category_id 
WHERE p.user_id = :current_user_id AND c.user_id = :current_user_id;
```

### Multi-Tenant Constraints
All tables have constraints that ensure references belong to the same user:

```sql
-- Example in product_variants
CONSTRAINT same_user_check CHECK (
  product_id IN (SELECT id FROM products WHERE user_id = NEW.user_id)
)
```

### Multi-Tenant Data Model
The application uses **multi-tenant** architecture where each user (tenant) has completely isolated data. **All tables include `user_id`** as foreign key to guarantee data isolation.

#### Benefits:
- âœ… **Complete data isolation**: Each user only sees their own data
- âœ… **Scalable for thousands of users**: Architecture prepared to grow
- âœ… **Database-level security**: user_id in all tables prevents cross-access
- âœ… **Referential integrity**: All relationships respect the tenant (user_id)
- âœ… **Automatically filtered queries**: user_id always included in queries

### Table Structure

#### 1. Users
```javascript
{
  id: Integer (PK, Auto-increment)
  email: String (Unique, Required)
  password_hash: String (Required)
  first_name: String (Required)
  last_name: String (Required)
  business_name: String (Optional)
  is_active: Boolean (Default: true)
  email_verified: Boolean (Default: false)
  email_verification_token: String (Optional) // JWT token for email verification
  email_verification_expires: DateTime (Optional) // Token expiration (24 hours)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

#### 2. Customers
```javascript
{
  id: Integer (PK, Auto-increment)
  user_id: Integer (FK -> users.id, Required)
  first_name: String (Required)
  last_name: String (Required)
  company: String (Optional)
  phone: String (Optional)
  email: String (Required)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Unique constraint per user
  UNIQUE(user_id, email)
}
```

#### 3. Suppliers
```javascript
{
  id: Integer (PK, Auto-increment)
  user_id: Integer (FK -> users.id, Required)
  first_name: String (Required)
  last_name: String (Required)
  company: String (Optional)
  phone: String (Optional)
  email: String (Required)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Unique constraint per user
  UNIQUE(user_id, email)
}
```

#### 4. Categories (Self-referential)
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  name: String (Required)
  description: String (Optional)
  parent_id: Integer (FK -> categories.id, Optional)
  level: Integer (Default: 0, 0=root, 1=subcategory, etc.)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

**Hierarchy example:**
```
id=1, name="Beer Supplies", parent_id=null, level=0
id=2, name="Hops", parent_id=1, level=1
id=3, name="American Hops", parent_id=2, level=2
id=4, name="Malts", parent_id=1, level=1
```

#### 5. Products
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  name: String (Required)
  description: String (Optional)
  selling_price: Decimal (Required) // Selling price - @db.Decimal(10, 2)
  category_id: Integer (FK -> categories.id)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

#### 6. Product_Variants
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  product_id: Integer (FK -> products.id)
  variant_name: String (Required) // "Default" for products without variants
  is_default: Boolean (Default: false) // Reliable default variant identifier
  selling_price_modifier: Decimal (Default: 0) // +/- on selling_price - @db.Decimal(10, 2)
  stock: Integer (Default: 0) // ONLY place where stock is managed
  attributes: Json (Optional) // Custom attributes
  min_stock_alert: Integer (Default: 0) // Minimum stock alert
  enable_stock_alerts: Boolean (Default: true)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Note: Unique constraint for is_default must be implemented at application level
  // since PostgreSQL doesn't support partial unique constraints with Prisma
}
```

**Use cases**:
- **Simple product**: variant_name = "Default", handles product stock
- **Product with variants**: Each variant (size, color, etc.) with independent stock

#### 7. Variant_Suppliers
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  variant_id: Integer (FK -> product_variants.id)
  supplier_id: Integer (FK -> suppliers.id)
  purchase_price: Decimal (Required) // Purchase price - @db.Decimal(10, 2)
  is_primary_supplier: Boolean (Default: false)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Unique constraint: one supplier per variant per user
  UNIQUE(user_id, variant_id, supplier_id)
}
```

## Email Verification System with Nodemailer OAuth2

### Configuration Required

#### Environment Variables:
```env
# Email Configuration (Gmail OAuth2)
GMAIL_USER=your-email@gmail.com
GMAIL_CLIENT_ID=your_client_id_from_google_cloud
GMAIL_CLIENT_SECRET=your_client_secret_from_google_cloud
GMAIL_REFRESH_TOKEN=your_refresh_token_from_oauth_playground

# Frontend URL (for verification links)
FRONTEND_URL=https://your-frontend-domain.com
```

### Google OAuth2 Setup Process:
1. **Google Cloud Console**: Create project â†’ Enable Gmail API
2. **OAuth2 Credentials**: Create OAuth2 Client ID (Web application)
3. **OAuth Playground**: Generate refresh token with `https://mail.google.com/` scope
4. **Test Users**: Add test users in OAuth consent screen (for development)

### Email Service Features:
- âœ… **Graceful configuration handling**: App starts even if email env vars are missing
- âœ… **Professional HTML templates**: Responsive design with StockFacil branding
- âœ… **JWT token security**: 24-hour expiration with email verification purpose
- âœ… **Connection verification**: Built-in health check for OAuth2 setup
- âœ… **Error handling**: Detailed error messages and logging
- âœ… **Test email capability**: Built-in method for testing configuration

### Email Verification Flow:
1. **User Registration**: Created with `email_verified = false`
2. **Send Verification**: `POST /auth/send-verification` generates JWT token and sends email
3. **User Clicks Link**: Email contains verification URL with token
4. **Email Verified**: `GET /auth/verify-email/:token` validates and sets `email_verified = true`
5. **Status Check**: `GET /auth/verification-status` allows frontend to check status

### Dependencies:
```json
{
  "nodemailer": "^6.9.7"
}
```

## Important Design Decisions

### 1. Separate Tables for Customers and Suppliers
**Decision**: Create separate `customers` and `suppliers` tables with identical structure.

**Benefits**:
- âœ… Clear separation of responsibilities
- âœ… Immediate identification of contact role
- âœ… Allows different business logic in the future
- âœ… Scalability to add specific fields

### 2. Stock Control Only in Variants
**Decision**: Stock is managed exclusively at product variant level.

**Implementation**:
- **Products WITHOUT variants**: A **DEFAULT variant** is automatically created
- **Products WITH variants**: Each variant manages its own stock
- Default variant allows defining stock and minimum stock for simple products

**Rationale**:
- Consistency: all stock logic is centralized in `product_variants`
- Flexibility: allows evolution from simple product to product with variants
- Simplicity: single place to query stock regardless of product type

### 3. Self-referential Category Hierarchy
**Decision**: Use self-referential table for categories with multiple levels.

**Benefits**:
- âœ… Complete flexibility in structure
- âœ… Support for unlimited nested categories
- âœ… Easy navigation and organization

### 4. Multiple Suppliers per Variant
**Decision**: Allow multiple suppliers per variant with different prices.

**Benefits**:
- âœ… Price comparison
- âœ… Backup suppliers
- âœ… Cost optimization

### 5. Authentication and Authorization
**Decision**: Complete JWT implementation with protection on all routes except auth.

**Implementation**:
- **Public routes**: Only `POST /auth/login`, `POST /auth/register`, and `GET /auth/verify-email/:token`
- **Protected routes**: All others (including user profile management)
- **Profile routes**: `PATCH /auth/profile` and `DELETE /auth/profile` for better security
- **Middleware**: Automatic user_id extraction from JWT token
- **Multi-tenant security**: user_id always validated in each operation

### 6. Query Optimization for findAll Products
**Decision**: Use raw SQL with JSON aggregation for maximum performance.

**Implementation**:
- Raw SQL query for findAll (critical performance with many products)
- Prisma for findById (less critical, more readable)
- Consistent format between both endpoints
- Explicit cast to avoid BigInt serialization errors
- JSON aggregation to include variants in single query

**Benefits**:
- âœ… **Performance**: Single query vs multiple roundtrips
- âœ… **Consistency**: Same response format in findAll and findById
- âœ… **Scalability**: Optimized to handle large product volumes
- âœ… **Maintainability**: Clear and documented structure

### 7. Unified Response Format for Prices
**Decision**: Convert all Decimal fields to Number in API responses.

**Implementation**:
- Middleware/utility to convert `selling_price`, `selling_price_modifier`, `purchase_price` from string to number
- Swagger schema updated with 'number' type for all prices
- Total consistency between database (Decimal) and API (Number)

**Rationale**:
- âœ… **Improved UX**: Frontend receives numbers directly
- âœ… **Precision maintained**: Database still uses Decimal
- âœ… **Consistency**: All endpoints return the same format
- âœ… **Compatibility**: Works perfectly with JSON and JavaScript

### 8. Complete API Documentation with Swagger
**Decision**: Implement comprehensive Swagger documentation for all endpoints.

**Implementation**:
- Detailed schemas for all entities (Product, ProductVariant, Agenda, Category, User, VariantSupplier, Error)
- Complete endpoint documentation with authentication, validation, and error handling
- Practical examples and realistic data
- Consistent English documentation
- Proper data types (number for prices, not float/string)
- **swagger-jsdoc format** for better code organization and maintainability
- **ðŸ†• Detailed Email Verification Documentation**: Complete Swagger specs for all 3 email verification endpoints with request/response examples, authentication requirements, error codes, and detailed descriptions

**Benefits**:
- âœ… **Developer Experience**: Clear API contract and examples
- âœ… **Frontend Integration**: Precise schema for client generation
- âœ… **Testing**: Easy endpoint testing with Swagger UI
- âœ… **Documentation**: Self-documenting API with up-to-date examples
- âœ… **Maintainability**: Documentation close to route definitions
- âœ… **Email Verification**: Complete documentation for email workflow implementation

### 9. Profile-based User Management
**Decision**: Use `/auth/profile` routes instead of `/users/:id` for user operations.

**Implementation**:
- `PATCH /auth/profile` - Update current user's profile
- `DELETE /auth/profile` - Delete current user's account
- user_id automatically extracted from JWT token

**Benefits**:
- âœ… **Enhanced Security**: No risk of ID manipulation in URLs
- âœ… **Simplified Frontend**: No need to track user IDs
- âœ… **Better UX**: Clear semantic meaning ("my profile")
- âœ… **Reduced Complexity**: Less validation logic needed

### 10. Advanced Pagination System
**Decision**: Implement comprehensive pagination with search and sorting for all list endpoints.

**Implementation**:
- **Complete pagination metadata**: 10 fields including currentPage, totalPages, totalItems, itemsPerPage, hasNextPage, hasPreviousPage, nextPage, previousPage, startItem, endItem
- **Search functionality**: Generic search across relevant fields (name, email, company, etc.)
- **Flexible sorting**: sortBy any field, sortOrder (asc/desc) with sensible defaults
- **Performance limits**: Maximum 100 items per page to prevent performance issues
- **Applied to**: GET /products, /customers, /suppliers, /variants endpoints

**Benefits**:
- âœ… **Improved Performance**: Controlled data loading prevents overwhelming responses
- âœ… **Better UX**: Users can find data quickly with search and sorting
- âœ… **Scalability**: Handles thousands of records efficiently
- âœ… **Consistent Interface**: Same pagination format across all entities
- âœ… **Complete Metadata**: Frontend gets all information needed for pagination UI
- âœ… **Flexibility**: Supports various sorting and filtering requirements

### 11. Email Verification System with Nodemailer OAuth2
**Decision**: Implement complete email verification using Gmail OAuth2 with Nodemailer for production-ready, free email service.

**Implementation**:
- `POST /auth/send-verification` - Send/resend verification email to authenticated user (204 No Content)
- `GET /auth/verify-email/:token` - Verify email using JWT token from email link (204 No Content)
- `GET /auth/verification-status` - Check current verification status for authenticated user (200 with data)
- JWT tokens for email verification with 24-hour expiration
- Database fields: `email_verification_token`, `email_verification_expires`
- **Nodemailer with Gmail OAuth2** - Direct implementation with graceful error handling
- HTML email templates with professional design and StockFacil branding
- API link verification with proper success/error handling
- **ðŸ†• Complete Swagger Documentation**: All 3 email verification endpoints fully documented with detailed request/response schemas, authentication requirements, error handling, and practical examples
- **ðŸ†• HTTP Semantics**: Proper use of 204 No Content for actions without return data, 200 OK for data responses

**Gmail OAuth2 Configuration**:
- **Environment Variables**: `GMAIL_USER`, `GMAIL_CLIENT_ID`, `GMAIL_CLIENT_SECRET`, `GMAIL_REFRESH_TOKEN`
- **Dependencies**: Only `nodemailer` (modern, maintained library)
- **OAuth2 Setup**: Google Cloud Console â†’ Gmail API â†’ OAuth2 credentials â†’ Refresh token
- **Express 5 Compatible**: Modern implementation without deprecated libraries

**Benefits**:
- âœ… **Completely Free**: Gmail OAuth2 with no production limits
- âœ… **High Deliverability**: Gmail service ensures emails reach inbox
- âœ… **Production Ready**: OAuth2 authentication with proper token management
- âœ… **Modern Implementation**: Only maintained dependencies, Express 5 compatible
- âœ… **Graceful Degradation**: App runs even if email service is misconfigured
- âœ… **Security**: JWT tokens with purpose validation and expiration
- âœ… **Professional**: HTML email templates with responsive design
- âœ… **Developer Friendly**: Built-in testing methods and connection verification
- âœ… **Fully Documented**: Complete Swagger documentation for all email verification endpoints
- âœ… **HTTP Standards Compliant**: Uses 204 No Content for actions, 200 OK for data responses

## Business Logic: Products and Variants

### Flow for Products Without Variants
1. **Product creation**: Created normally
2. **Automatic variant**: System creates a variant with:
   - `variant_name = "Default"`
   - `selling_price_modifier = 0`
   - `is_default = true`
   - `stock` and `min_stock_alert` defined by user (default 0)
3. **Stock management**: All stock is managed in default variant

### Flow for Products With Variants
1. **Product creation**: Created normally
2. **Custom variants**: User creates specific variants:
   - Example: "Size S", "Size M", "Size L"
   - Each with `is_default = false`
   - Independent stock and alerts (default stock 0)
3. **Distributed stock**: Each variant manages its own inventory

### Frontend has_variants Calculation
**Decision**: Remove `has_variants` from backend and calculate it on client.

```javascript
// In frontend
const hasVariants = product.variants.some(variant => !variant.is_default);
```

**Advantages**:
- âœ… Simpler and faster query
- âœ… Less data redundancy
- âœ… Trivial logic easy to implement on client

### Unified Response Format

Both `findAll` and `findById` return the same format with **default variant always included**:

#### Product WITH custom variants:
```json
{
    "id": 12,
    "name": "Product1",
    "selling_price": 100.00,
    "description": null,
    "category": {
        "id": 4,
        "name": "Category1"
    },
    "created_at": "2025-08-12T22:01:33.012Z",
    "updated_at": "2025-08-12T22:01:33.012Z",
    "variants": [
        {
            "id": 11,
            "variant_name": "Size S",
            "stock": 25,
            "selling_price_modifier": 0.00,
            "min_stock_alert": 5,
            "enable_stock_alerts": true,
            "is_default": false,
            "attributes": null
        },
        {
            "id": 12,
            "variant_name": "Size M", 
            "stock": 1,
            "selling_price_modifier": 10.00,
            "min_stock_alert": 3,
            "enable_stock_alerts": true,
            "is_default": false,
            "attributes": null
        }
    ],
    "total_stock": 26
}
```

#### Product WITHOUT custom variants (only default):
```json
{
    "id": 15,
    "name": "Simple Product",
    "selling_price": 50.00,
    "description": null,
    "category": {
        "id": 4,
        "name": "Category1"
    },
    "created_at": "2025-08-12T22:01:33.012Z",
    "updated_at": "2025-08-12T22:01:33.012Z",
    "variants": [
        {
            "id": 20,
            "variant_name": "Default",
            "stock": 100,
            "selling_price_modifier": 0.00,
            "min_stock_alert": 10,
            "enable_stock_alerts": true,
            "is_default": true,
            "attributes": null
        }
    ],
    "total_stock": 100
}
```

### Advantages of This Approach
âœ… **Absolute consistency**: Always query stock in `product_variants`, even for "simple" products
âœ… **Scalability**: Easy migration from simple product to product with variants
âœ… **Flexibility**: Different prices, stock and alerts per variant
âœ… **Simplicity in queries**: Single place to get stock information
âœ… **Unified format**: Same structure in all endpoints
âœ… **Centralized logic**: No special cases for products "without variants"

### Practical Example
```sql
-- Get total stock for a product (with or without variants)
SELECT SUM(pv.stock) as total_stock
FROM product_variants pv 
WHERE pv.product_id = :product_id AND pv.user_id = :user_id;

-- Get products with low stock
SELECT p.name, pv.variant_name, pv.stock, pv.min_stock_alert
FROM products p
JOIN product_variants pv ON p.id = pv.product_id
WHERE pv.stock <= pv.min_stock_alert 
  AND pv.enable_stock_alerts = true
  AND p.user_id = :user_id;

-- Determine if a product has custom variants
SELECT p.*, 
       CASE WHEN EXISTS(
         SELECT 1 FROM product_variants pv 
         WHERE pv.product_id = p.id AND pv.is_default = false
       ) THEN true ELSE false END as has_variants
FROM products p 
WHERE p.user_id = :user_id;
```

## API Documentation Progress

### âœ… **Completed Documentation**:

#### **Core Entities**:
- Products CRUD (5 endpoints) - **with advanced pagination**
- Product Variants CRUD (5 endpoints) - **with advanced pagination**
- Categories CRUD (5 endpoints)
- Customers CRUD (5 endpoints) - **with advanced pagination**
- Suppliers CRUD (5 endpoints) - **with advanced pagination**
- Authentication (7 endpoints) - **with Nodemailer OAuth2 email verification system**
- Variant-Suppliers CRUD (5 endpoints)

#### **ðŸ†• Email Verification Endpoints - Complete Swagger Documentation**:
All 3 email verification endpoints now have **comprehensive Swagger documentation**:

1. **POST /auth/send-verification**:
   - âœ… **Complete request/response schemas** with examples
   - âœ… **Authentication requirements** (JWT Bearer token)
   - âœ… **Error handling documentation** (401, 409, 500)
   - âœ… **Detailed description** including Nodemailer OAuth2 implementation
   - âœ… **Response format**: `{message: "Verification email sent successfully"}`

2. **GET /auth/verify-email/:token**:
   - âœ… **Path parameter schema** for JWT token
   - âœ… **Public endpoint documentation** (no authentication required)
   - âœ… **Success response schema** with user object
   - âœ… **Error scenarios** (400 invalid token, 404 user not found, 500 server error)
   - âœ… **Token validation description** and single-use security

3. **GET /auth/verification-status**:
   - âœ… **Authentication requirements** (JWT Bearer token)
   - âœ… **Response schema** with email_verified boolean and email
   - âœ… **Error handling** (401, 500)
   - âœ… **Usage description** for frontend integration

#### **Total Documented**: **42/42 endpoints** ðŸŽ‰

### **Statistics Endpoints**:
- GET /stats/inventory - **Inventory statistics** (products count, low stock alerts, out of stock items)
- GET /stats/agenda - **Agenda statistics** (customers count, suppliers count)

### **Utility Endpoints**:
- GET / - **Root endpoint** (API information and documentation link)
- GET /health - **Health check** (status, timestamp, environment)

### **Advanced Pagination Features**:
- **4 endpoints with full pagination**: Products, Variants, Customers, Suppliers
- **Complete metadata**: 10 pagination fields for optimal UX
- **Search functionality**: Cross-field search capability
- **Flexible sorting**: sortBy field + sortOrder direction
- **Performance optimized**: Max 100 items per page limit
- **Query parameters**: page, limit, search, sortBy, sortOrder

### **Pagination Response Format**:
```json
{
  "products": [...], // or customers, suppliers, variants
  "pagination": {
    "currentPage": 1,
    "totalPages": 5,
    "totalItems": 48,
    "itemsPerPage": 10,
    "hasNextPage": true,
    "hasPreviousPage": false,
    "nextPage": 2,
    "previousPage": null,
    "startItem": 1,
    "endItem": 10
  }
}
```

### **ðŸ† API Documentation: 100% Complete with Production Deployment**

All endpoints have been documented with:
âœ… Complete swagger-jsdoc format
âœ… Advanced pagination schemas and parameters
âœ… **ðŸ†• Complete Email Verification Documentation** - All 3 endpoints fully documented with detailed schemas
âœ… **Nodemailer OAuth2 email verification system** for secure user authentication
âœ… Statistics endpoints for inventory and agenda management
âœ… Utility endpoints for health monitoring and API information
âœ… Production deployment on Render with full environment configuration
âœ… Realistic examples and data
âœ… Consistent response formats
âœ… Proper authentication requirements
âœ… Comprehensive error handling
âœ… Detailed request/response schemas
âœ… Consistent English descriptions
âœ… Search and sorting capabilities

## Production Configuration

### Environment Variables for Production:
```env
# Database
DATABASE_URL=your_production_database_url

# JWT
JWT_SECRET=your_secure_jwt_secret

# Server
PORT=3000
NODE_ENV=production

# Email Configuration (Gmail OAuth2)
GMAIL_USER=your-business-email@gmail.com
GMAIL_CLIENT_ID=your_google_cloud_client_id
GMAIL_CLIENT_SECRET=your_google_cloud_client_secret
GMAIL_REFRESH_TOKEN=your_oauth2_refresh_token

# Frontend URL
FRONTEND_URL=https://your-frontend-domain.com
```

### Deployment Checklist:
- âœ… PostgreSQL database configured
- âœ… All environment variables set
- âœ… Gmail OAuth2 credentials configured
- âœ… SSL/HTTPS enabled
- âœ… CORS properly configured
- âœ… Rate limiting enabled
- âœ… Security headers (Helmet) active
- âœ… API documentation accessible
- âœ… Health check endpoint working
- âœ… Multi-tenant security verified
- âœ… **Email verification system fully functional with Nodemailer OAuth2**
- âœ… **All 42 endpoints documented in Swagger with complete schemas**