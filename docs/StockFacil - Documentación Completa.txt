# StockFacil - DocumentaciÃ³n Completa del Proyecto

## InformaciÃ³n General del Proyecto

### DescripciÃ³n
**StockFacil** es una aplicaciÃ³n web para la gestiÃ³n integral de inventarios, clientes y proveedores de empresas. Permite a las empresas mantener control completo sobre su stock, precios, relaciones comerciales y estructura de productos con variantes.

### Tipo de AplicaciÃ³n
- **Frontend**: AplicaciÃ³n Web
- **Backend**: API REST 
- **Base de Datos**: PostgreSQL con Prisma ORM

### Estado Actual del Desarrollo
âœ… **Completado**:
- Esquema de base de datos definido
- Schema de Prisma configurado
- Rutas CRUD implementadas para:
  - Usuarios
  - Clientes
  - Proveedores
  - CategorÃ­as
  - Productos
  - Variantes de productos
  - **Variant-Suppliers** (relaciÃ³n variantes-proveedores):
    - `GET /suppliers/:supplierId/variants` - Obtener variantes de un proveedor
    - `POST /variant-suppliers/` - Crear relaciÃ³n variant-supplier
    - `GET /variant-suppliers/:id` - Obtener relaciÃ³n especÃ­fica
    - `PATCH /variant-suppliers/:id` - Actualizar precio/proveedor principal
    - `DELETE /variant-suppliers/:id` - Eliminar relaciÃ³n
- Validaciones con express-validator implementadas
- **AutenticaciÃ³n JWT implementada**:
  - Login y register (rutas pÃºblicas)
  - Todas las demÃ¡s rutas requieren autenticaciÃ³n (incluyendo update de usuario)
  - Middleware de autorizaciÃ³n configurado
  - ExtracciÃ³n automÃ¡tica de user_id del token
- **Query optimizada para findAll productos**:
  - Raw SQL con performance optimizada para listados
  - Formato consistente con findById
  - JSON aggregation para variantes
  - Cast explÃ­cito para evitar BigInt serialization errors
- **Formato de respuesta unificado**:
  - ConversiÃ³n automÃ¡tica de Decimal a Number en respuestas
  - Schema de Swagger actualizado con tipo 'number' para precios
  - Consistencia total entre findAll y findById

ðŸ”„ **En desarrollo**:
- PaginaciÃ³n para productos, clientes, proveedores

## Arquitectura Multi-Tenant

### Principio Fundamental
**TODAS las tablas (excepto `users`) incluyen `user_id` como clave forÃ¡nea** para garantizar que cada tenant (usuario) solo pueda acceder a sus propios datos.

### ImplementaciÃ³n de Seguridad Multi-Tenant
```sql
-- Ejemplo de query seguro que siempre incluye user_id
SELECT * FROM products WHERE user_id = :current_user_id AND id = :product_id;

-- Las relaciones tambiÃ©n respetan el tenant
SELECT p.*, c.name as category_name 
FROM products p 
JOIN categories c ON c.id = p.category_id 
WHERE p.user_id = :current_user_id AND c.user_id = :current_user_id;
```

### Constraints Multi-Tenant
Todas las tablas tienen constraints que aseguran que las referencias pertenezcan al mismo usuario:

```sql
-- Ejemplo en product_variants
CONSTRAINT same_user_check CHECK (
  product_id IN (SELECT id FROM products WHERE user_id = NEW.user_id)
)
```

### Modelo de Datos Multi-Tenant
La aplicaciÃ³n utiliza arquitectura **multi-tenant** donde cada usuario (tenant) tiene datos completamente aislados. **Todas las tablas incluyen `user_id`** como clave forÃ¡nea para garantizar el aislamiento de datos.

#### Beneficios:
- âœ… **Completo aislamiento de datos**: Cada usuario solo ve sus propios datos
- âœ… **Escalable para miles de usuarios**: Arquitectura preparada para crecer
- âœ… **Seguridad a nivel de base de datos**: user_id en todas las tablas previene acceso cruzado
- âœ… **Integridad referencial**: Todas las relaciones respetan el tenant (user_id)
- âœ… **Queries automÃ¡ticamente filtradas**: Siempre se incluye user_id en las consultas

### Estructura de Tablas

#### 1. Users (Usuarios)
```javascript
{
  id: Integer (PK, Auto-increment)
  email: String (Ãšnico, Requerido)
  password_hash: String (Requerido)
  first_name: String (Requerido)
  last_name: String (Requerido)
  business_name: String (Opcional)
  is_active: Boolean (Default: true)
  email_verified: Boolean (Default: false)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

#### 2. Customers (Clientes)
```javascript
{
  id: Integer (PK, Auto-increment)
  user_id: Integer (FK -> users.id, Requerido)
  first_name: String (Requerido)
  last_name: String (Requerido)
  company: String (Opcional)
  phone: String (Opcional)
  email: String (Requerido)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Constraint Ãºnico por usuario
  UNIQUE(user_id, email)
}
```

#### 3. Suppliers (Proveedores)
```javascript
{
  id: Integer (PK, Auto-increment)
  user_id: Integer (FK -> users.id, Requerido)
  first_name: String (Requerido)
  last_name: String (Requerido)
  company: String (Opcional)
  phone: String (Opcional)
  email: String (Requerido)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Constraint Ãºnico por usuario
  UNIQUE(user_id, email)
}
```

#### 4. Categories (CategorÃ­as) - Auto-referencial
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Requerido)
  name: String (Requerido)
  description: String (Opcional)
  parent_id: Integer (FK -> categories.id, Opcional)
  level: Integer (Default: 0, 0=raÃ­z, 1=subcategorÃ­a, etc.)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

**Ejemplo de jerarquÃ­a:**
```
id=1, name="Suministros para Cerveza", parent_id=null, level=0
id=2, name="LÃºpulos", parent_id=1, level=1
id=3, name="LÃºpulos Americanos", parent_id=2, level=2
id=4, name="Maltas", parent_id=1, level=1
```

#### 5. Products (Productos)
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Requerido)
  name: String (Requerido)
  description: String (Opcional)
  selling_price: Decimal (Requerido) // Precio de venta - @db.Decimal(10, 2)
  category_id: Integer (FK -> categories.id)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

#### 6. Product_Variants (Variantes de Producto)
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Requerido)
  product_id: Integer (FK -> products.id)
  variant_name: String (Requerido) // "Default" para productos sin variantes
  is_default: Boolean (Default: false) // Identificador confiable de variante default
  selling_price_modifier: Decimal (Default: 0) // +/- sobre selling_price - @db.Decimal(10, 2)
  stock: Integer (Default: 0) // ÃšNICO lugar donde se maneja stock
  attributes: Json (Opcional) // Atributos personalizados
  min_stock_alert: Integer (Default: 0) // Alerta de stock mÃ­nimo
  enable_stock_alerts: Boolean (Default: true)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Nota: El constraint Ãºnico para is_default se debe implementar a nivel de aplicaciÃ³n
  // ya que PostgreSQL no soporta partial unique constraints con Prisma
}
```

**Casos de uso**:
- **Producto simple**: variant_name = "Default", maneja stock del producto
- **Producto con variantes**: Cada variante (talle, color, etc.) con stock independiente

#### 7. Variant_Suppliers (Proveedores por Variante)
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Requerido)
  variant_id: Integer (FK -> product_variants.id)
  supplier_id: Integer (FK -> suppliers.id)
  purchase_price: Decimal (Requerido) // Precio de compra - @db.Decimal(10, 2)
  is_primary_supplier: Boolean (Default: false)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Constraint Ãºnico: un proveedor por variante por usuario
  UNIQUE(user_id, variant_id, supplier_id)
}
```

## Decisiones de DiseÃ±o Importantes

### 1. Tablas Separadas para Clientes y Proveedores
**DecisiÃ³n**: Crear tablas separadas `customers` y `suppliers` con estructura idÃ©ntica.

**Beneficios**:
- âœ… Clara separaciÃ³n de responsabilidades
- âœ… IdentificaciÃ³n inmediata del rol del contacto
- âœ… Permite lÃ³gica de negocio diferente en el futuro
- âœ… Escalabilidad para agregar campos especÃ­ficos

### 2. Control de Stock Solo en Variantes
**DecisiÃ³n**: El stock se maneja Ãºnicamente a nivel de variantes de producto.

**ImplementaciÃ³n**:
- **Productos SIN variantes**: Se crea automÃ¡ticamente una **variante DEFAULT**
- **Productos CON variantes**: Cada variante maneja su propio stock
- La variante default permite definir stock y stock mÃ­nimo para productos simples

**Rationale**:
- Consistencia: toda la lÃ³gica de stock estÃ¡ centralizada en `product_variants`
- Flexibilidad: permite evolucionar de producto simple a producto con variantes
- Simplicidad: un solo lugar para consultar stock independientemente del tipo de producto

### 3. JerarquÃ­a de CategorÃ­as Auto-referencial
**DecisiÃ³n**: Usar tabla auto-referencial para categorÃ­as con mÃºltiples niveles.

**Beneficios**:
- âœ… Flexibilidad completa en la estructura
- âœ… Soporte para categorÃ­as anidadas ilimitadas
- âœ… FÃ¡cil navegaciÃ³n y organizaciÃ³n

### 4. MÃºltiples Proveedores por Variante
**DecisiÃ³n**: Permitir mÃºltiples proveedores por variante con precios diferentes.

**Beneficios**:
- âœ… ComparaciÃ³n de precios
- âœ… Proveedores de respaldo
- âœ… OptimizaciÃ³n de costos

### 5. AutenticaciÃ³n y AutorizaciÃ³n
**DecisiÃ³n**: ImplementaciÃ³n completa de JWT con protecciÃ³n en todas las rutas.

**ImplementaciÃ³n**:
- **Rutas pÃºblicas**: Solo `POST /auth/login` y `POST /auth/register`
- **Rutas protegidas**: Todas las demÃ¡s (incluyendo update de usuario)
- **Middleware**: ExtracciÃ³n automÃ¡tica de user_id del token JWT
- **Seguridad multi-tenant**: user_id siempre validado en cada operaciÃ³n

### 6. Query Optimization para findAll Products
**DecisiÃ³n**: Usar raw SQL con JSON aggregation para mÃ¡ximo rendimiento.

**ImplementaciÃ³n**:
- Raw SQL query para findAll (performance crÃ­tica con muchos productos)
- Prisma para findById (menos crÃ­tico, mÃ¡s legible)
- Formato consistente entre ambos endpoints
- Cast explÃ­cito para evitar BigInt serialization errors
- JSON aggregation para incluir variantes en una sola query

**Benefits**:
- âœ… **Performance**: Una sola query vs mÃºltiples roundtrips
- âœ… **Consistencia**: Mismo formato de respuesta en findAll y findById
- âœ… **Escalabilidad**: Optimizado para manejar grandes volÃºmenes de productos
- âœ… **Mantenibilidad**: Estructura clara y documentada

### 7. Formato de Respuesta Unificado para Precios
**DecisiÃ³n**: Convertir todos los campos Decimal a Number en las respuestas de la API.

**ImplementaciÃ³n**:
- Middleware/utilidad para convertir `selling_price`, `selling_price_modifier`, `purchase_price` de string a number
- Schema de Swagger actualizado con tipo 'number' para todos los precios
- Consistencia total entre base de datos (Decimal) y API (Number)

**Rationale**:
- âœ… **UX mejorada**: Frontend recibe nÃºmeros directamente
- âœ… **PrecisiÃ³n mantenida**: Base de datos sigue usando Decimal
- âœ… **Consistencia**: Todos los endpoints devuelven el mismo formato
- âœ… **Compatibilidad**: Funciona perfectamente con JSON y JavaScript

## LÃ³gica de Negocio: Productos y Variantes

### Flujo para Productos Sin Variantes
1. **CreaciÃ³n del producto**: Se crea normalmente
2. **Variante automÃ¡tica**: El sistema crea una variante con:
   - `variant_name = "Default"`
   - `selling_price_modifier = 0`
   - `is_default = true`
   - `stock` y `min_stock_alert` definidos por el usuario (default 0)
3. **GestiÃ³n de stock**: Todo el stock se maneja en la variante default

### Flujo para Productos Con Variantes
1. **CreaciÃ³n del producto**: Se crea normalmente
2. **Variantes personalizadas**: El usuario crea variantes especÃ­ficas:
   - Ejemplo: "Talle S", "Talle M", "Talle L"
   - Cada una con `is_default = false`
   - Stock y alertas independientes (stock default 0)
3. **Stock distribuido**: Cada variante maneja su propio inventario

### CÃ¡lculo de has_variants en Frontend
**DecisiÃ³n**: Eliminar `has_variants` del backend y calcularlo en el cliente.

```javascript
// En el frontend
const hasVariants = product.variants.some(variant => !variant.is_default);
```

**Ventajas**:
- âœ… Query mÃ¡s simple y rÃ¡pida
- âœ… Menos redundancia de datos
- âœ… LÃ³gica trivial fÃ¡cil de implementar en cliente

### Formato de Respuesta Unificado

Tanto `findAll` como `findById` devuelven el mismo formato con **variante default siempre incluida**:

#### Producto CON variantes personalizadas:
```json
{
    "id": 12,
    "name": "Product1",
    "selling_price": 100.00,
    "description": null,
    "category": {
        "id": 4,
        "name": "Categoria1"
    },
    "created_at": "2025-08-12T22:01:33.012Z",
    "updated_at": "2025-08-12T22:01:33.012Z",
    "variants": [
        {
            "id": 11,
            "variant_name": "Talle S",
            "stock": 25,
            "selling_price_modifier": 0.00,
            "min_stock_alert": 5,
            "enable_stock_alerts": true,
            "is_default": false,
            "attributes": null
        },
        {
            "id": 12,
            "variant_name": "Talle M", 
            "stock": 1,
            "selling_price_modifier": 10.00,
            "min_stock_alert": 3,
            "enable_stock_alerts": true,
            "is_default": false,
            "attributes": null
        }
    ],
    "total_stock": 26
}
```

#### Producto SIN variantes personalizadas (solo default):
```json
{
    "id": 15,
    "name": "Product Simple",
    "selling_price": 50.00,
    "description": null,
    "category": {
        "id": 4,
        "name": "Categoria1"
    },
    "created_at": "2025-08-12T22:01:33.012Z",
    "updated_at": "2025-08-12T22:01:33.012Z",
    "variants": [
        {
            "id": 20,
            "variant_name": "Default",
            "stock": 100,
            "selling_price_modifier": 0.00,
            "min_stock_alert": 10,
            "enable_stock_alerts": true,
            "is_default": true,
            "attributes": null
        }
    ],
    "total_stock": 100
}
```

### Ventajas de esta AproximaciÃ³n
âœ… **Consistencia absoluta**: Siempre consultar stock en `product_variants`, incluso para productos "simples"
âœ… **Escalabilidad**: FÃ¡cil migraciÃ³n de producto simple a producto con variantes
âœ… **Flexibilidad**: Diferentes precios, stock y alertas por variante
âœ… **Simplicidad en queries**: Un solo lugar para obtener informaciÃ³n de stock
âœ… **Formato unificado**: Misma estructura en todos los endpoints
âœ… **LÃ³gica centralizada**: No hay casos especiales para productos "sin variantes"

### Ejemplo PrÃ¡ctico
```sql
-- Obtener stock total de un producto (con o sin variantes)
SELECT SUM(pv.stock) as total_stock
FROM product_variants pv 
WHERE pv.product_id = :product_id AND pv.user_id = :user_id;

-- Obtener productos con stock bajo
SELECT p.name, pv.variant_name, pv.stock, pv.min_stock_alert
FROM products p
JOIN product_variants pv ON p.id = pv.product_id
WHERE pv.stock <= pv.min_stock_alert 
  AND pv.enable_stock_alerts = true
  AND p.user_id = :user_id;

-- Determinar si un producto tiene variantes personalizadas
SELECT p.*, 
       CASE WHEN EXISTS(
         SELECT 1 FROM product_variants pv 
         WHERE pv.product_id = p.id AND pv.is_default = false
       ) THEN true ELSE false END as has_custom_variants
FROM products p 
WHERE p.user_id = :user_id;
```

## Funcionalidades Principales

### GestiÃ³n de Usuarios
- Registro y autenticaciÃ³n con JWT
- VerificaciÃ³n de email
- GestiÃ³n de perfil de empresa
- Todas las rutas protegidas excepto login/register

### GestiÃ³n de Contactos
- **Clientes**: GestiÃ³n completa con informaciÃ³n de contacto y empresa
- **Proveedores**: GestiÃ³n completa con informaciÃ³n de contacto y empresa
- Aislamiento de datos por usuario

### GestiÃ³n de Inventario
- **CategorÃ­as**: JerarquÃ­a flexible multi-nivel
- **Productos**: InformaciÃ³n bÃ¡sica y precio de venta
- **Variantes**: Control detallado de stock, precios y atributos
  - **Variante Default**: AutomÃ¡tica para productos sin variantes personalizadas
  - **Variantes Personalizadas**: Para productos con mÃºltiples opciones
- **Stock Centralizado**: Toda la gestiÃ³n de inventario en `product_variants`
- **Alertas de Stock**: Configurables por variante (incluyendo default)

### GestiÃ³n de Proveedores
- MÃºltiples proveedores por producto/variante
- Precios de compra diferenciados
- Proveedor principal por variante

## TecnologÃ­as Utilizadas

### Backend
- **Node.js** con **Express.js**
- **Prisma ORM** para manejo de base de datos
- **PostgreSQL** como base de datos
- **express-validator** para validaciones
- **JWT** para autenticaciÃ³n y autorizaciÃ³n
- Rutas CRUD completas implementadas
- **Raw SQL queries** para optimizaciÃ³n de performance en listados

### Base de Datos
- **PostgreSQL** con esquema multi-tenant
- Relaciones complejas con integridad referencial
- Constraints Ãºnicos por usuario
- JSON aggregation para consultas optimizadas

## PrÃ³ximos Pasos Sugeridos

### Backend (API)
1. **Pendiente Inmediato**
   - **PaginaciÃ³n** (en desarrollo)
     - Implementar para productos, clientes, proveedores
     - ParÃ¡metros: `?page=1&limit=20`
     - Response con metadata de paginaciÃ³n

2. **Funcionalidades Avanzadas**
   - Sistema de alertas de stock bajo
   - Reportes de inventario
   - Historial de movimientos de stock
   - API para bÃºsquedas y filtros

3. **Optimizaciones**
   - Ãndices de base de datos
   - CachÃ© para consultas frecuentes
   - Monitoring de performance

### Casos de uso especÃ­ficos:
- **Asignar proveedor principal**: AutomÃ¡ticamente des-marcar otros como principales
- **Comparar precios**: Obtener todos los proveedores de una variante con sus precios
- **GestiÃ³n de proveedores**: Ver todas las variantes que suministra un proveedor
- **ActualizaciÃ³n restrictiva**: Solo precio y flag principal pueden modificarse
- **Cambio de proveedor/variante**: Requiere eliminar relaciÃ³n existente y crear nueva

### LÃ³gica de Negocio Variant-Suppliers
```javascript
// âœ… Permitido en UPDATE
{
  purchase_price: Decimal, // Nuevo precio de compra
  is_primary_supplier: Boolean // Cambiar si es proveedor principal
}

// âŒ NO permitido en UPDATE - Requiere DELETE + POST
{
  variant_id: Integer, // Cambiar variante
  supplier_id: Integer, // Cambiar proveedor
  user_id: Integer // Siempre del usuario autenticado
}
```

**RazÃ³n**: Mantener integridad de la relaciÃ³n y evitar confusiÃ³n en histÃ³ricos de precios.

### DesestructuraciÃ³n para Updates Parciales
```javascript
// JavaScript permite desestructuraciÃ³n sin errores
const { purchase_price, is_primary_supplier } = req.body;

// Si alguna propiedad no existe, serÃ¡ undefined
// purchase_price = undefined (si no se envÃ­a)
// is_primary_supplier = true (si se envÃ­a)

// Construir objeto de actualizaciÃ³n dinÃ¡mico
const updateData = {};
if (purchase_price !== undefined) updateData.purchase_price = purchase_price;
if (is_primary_supplier !== undefined) updateData.is_primary_supplier = is_primary_supplier;
```

### Frontend
1. **Interfaz de Usuario**
   - Dashboard principal
   - GestiÃ³n de inventario
   - GestiÃ³n de contactos
   - Reportes y analÃ­ticas

2. **Experiencia de Usuario**
   - DiseÃ±o responsive
   - Interfaz intuitiva
   - Notificaciones en tiempo real

### Despliegue
1. **Infraestructura**
   - ConfiguraciÃ³n de servidor
   - Base de datos en producciÃ³n
   - Variables de entorno
   - Monitoreo y logs

## Notas TÃ©cnicas Multi-Tenant

### Prisma Schema
- Generador configurado para output personalizado
- **Todas las relaciones incluyen user_id** para aislamiento de datos
- Constraints Ãºnicos combinados con user_id (ej: `@@unique([user_id, email])`)
- Cascading deletes que respetan el tenant

### Validaciones y Seguridad
- express-validator implementado en todas las rutas
- **ValidaciÃ³n automÃ¡tica de user_id** en todas las operaciones
- Middleware para verificar ownership de recursos
- SanitizaciÃ³n de parÃ¡metros con control de tenant
- **Limpieza de datos**: PrevenciÃ³n de modificaciÃ³n de campos protegidos
  - ValidaciÃ³n de campos permitidos en middleware (express-validator)
  - Limpieza adicional en servicios para campos sensibles
  - ProtecciÃ³n contra modificaciÃ³n de: `user_id`, `id`, `createdAt`, `updatedAt`
  - **Nota**: `updatedAt` se maneja automÃ¡ticamente por Prisma (`@updatedAt`)

### Seguridad Multi-Tenant
- **Aislamiento garantizado**: user_id en todas las tablas
- **Queries automÃ¡ticamente filtradas** por tenant
- **Relaciones verificadas**: constraints que previenen referencias cruzadas
- **JWT implementado**: Middleware de autenticaciÃ³n con extracciÃ³n de user_id del token

### Performance Optimizations
- **Raw SQL para listados**: findAll products optimizado con raw queries
- **Prisma para operaciones individuales**: findById mantiene sintaxis ORM
- **JSON aggregation**: Variantes incluidas en una sola query
- **Cast explÃ­cito**: Evita errores de serializaciÃ³n BigInt
- **ConversiÃ³n automÃ¡tica**: Decimal a Number en respuestas
- **Ãndices**: Configurados para queries multi-tenant frecuentes

---

**Ãšltima actualizaciÃ³n**: Agosto 2025
**Estado del proyecto**: API base completada con autenticaciÃ³n JWT, variant-suppliers implementado, queries optimizadas, formato de respuesta unificado con conversiÃ³n automÃ¡tica de precios, paginaciÃ³n en desarrollo, listo para funcionalidades avanzadas y frontend