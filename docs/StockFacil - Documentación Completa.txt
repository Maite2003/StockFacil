# StockFacil - Complete Project Documentation

## General Project Information

### Description
**StockFacil** is a comprehensive web application for inventory, customer and supplier management for businesses. It allows companies to maintain complete control over their stock, prices, commercial relationships and product structure with variants.

### Application Type
- **Frontend**: Web Application
- **Backend**: REST API 
- **Database**: PostgreSQL with Prisma ORM

### Current Development Status
✅ **Completed**:
- Database schema defined
- Prisma schema configured
- CRUD routes implemented for:
  - Users
  - Customers
  - Suppliers
  - Categories
  - Products
  - Product variants
  - **Variant-Suppliers** (variant-supplier relationship):
    - `GET /suppliers/:supplierId/variants` - Get variants from a supplier
    - `POST /variant-suppliers/` - Create variant-supplier relationship
    - `GET /variant-suppliers/:id` - Get specific relationship
    - `PATCH /variant-suppliers/:id` - Update price/primary supplier
    - `DELETE /variant-suppliers/:id` - Delete relationship
- Validations with express-validator implemented
- **JWT Authentication implemented**:
  - Login and register (public routes)
  - All other routes require authentication (including user update)
  - Authorization middleware configured
  - Automatic user_id extraction from token
- **Optimized query for findAll products**:
  - Raw SQL with performance optimization for listings
  - Consistent format with findById
  - JSON aggregation for variants
  - Explicit casting to avoid BigInt serialization errors
- **Unified response format**:
  - Automatic Decimal to Number conversion in responses
  - Swagger schema updated with 'number' type for prices
  - Total consistency between findAll and findById
- **🆕 Advanced Pagination System**:
  - Complete pagination with metadata (currentPage, totalPages, totalItems, etc.)
  - Search functionality across relevant fields
  - Flexible sorting (sortBy field, sortOrder asc/desc)
  - Query parameters: page, limit, search, sortBy, sortOrder
  - Implemented in GET /products, /customers, /suppliers, /variants endpoints
  - Maximum 100 items per page for performance
- **🆕 API Documentation with Swagger**:
  - Complete schemas defined (Product, ProductVariant, Agenda, Category, User, VariantSupplier, Error)
  - **New Pagination Schemas**:
    - `Pagination` - Complete pagination metadata with 10 fields
    - `PaginatedProductsResponse` - Products with pagination
    - `PaginatedCustomersResponse` - Customers with pagination  
    - `PaginatedSuppliersResponse` - Suppliers with pagination
    - `PaginatedVariantsResponse` - Variants with pagination
  - **New Query Parameters**:
    - `PageParam` - Page number (1-based, default 1)
    - `LimitParam` - Items per page (1-100, default 10)
    - `SearchParam` - Search term filter
    - `SortByParam` - Field to sort by
    - `SortOrderParam` - Sort direction (asc/desc)
  - **Products CRUD endpoints documentation completed** ✅:
    - ✅ `POST /products` - Create new product (completed with specific response format)
    - ✅ `GET /products` - Get all products **with pagination, search & sorting** (completed with {products, pagination} format)
    - ✅ `GET /products/:id` - Get product by ID (completed with {product} format)
    - ✅ `PATCH /products/:id` - Update product (completed with {product} format)
    - ✅ `DELETE /products/:id` - Delete product (completed with 204 no content)
  - **Product Variants CRUD endpoints documentation completed** ✅:
    - ✅ `GET /products/:productId/variants` - Get all variants **with pagination, search & sorting** (with {variants, pagination} format)
    - ✅ `POST /products/:productId/variants` - Create new variant (with {variant} format)
    - ✅ `GET /products/:productId/variants/:id` - Get variant by ID (with {variant} format)
    - ✅ `PATCH /products/:productId/variants/:id` - Update variant (with {variant} format)
    - ✅ `DELETE /products/:productId/variants/:id` - Delete variant (204 no content)
  - **Categories CRUD endpoints documentation completed** ✅:
    - ✅ `GET /categories` - Get all categories (with {categories, length} format)
    - ✅ `POST /categories` - Create new category (with {Category} format)
    - ✅ `GET /categories/:id` - Get category by ID (with {category} format)
    - ✅ `PATCH /categories/:id` - Update category (with {category} format)
    - ✅ `DELETE /categories/:id` - Delete category (204 no content)
  - **Customers CRUD endpoints documentation completed** ✅:
    - ✅ `GET /customers` - Get all customers **with pagination, search & sorting** (with {customers, pagination} format)
    - ✅ `POST /customers` - Create new customer (with {Customer} format)
    - ✅ `GET /customers/:id` - Get customer by ID (with {customer} format)
    - ✅ `PATCH /customers/:id` - Update customer (with {customer} format)
    - ✅ `DELETE /customers/:id` - Delete customer (204 no content)
  - **Suppliers CRUD endpoints documentation completed** ✅:
    - ✅ `GET /suppliers` - Get all suppliers **with pagination, search & sorting** (with {suppliers, pagination} format)
    - ✅ `POST /suppliers` - Create new supplier (with {Supplier} format)
    - ✅ `GET /suppliers/:id` - Get supplier by ID (with {supplier} format)
    - ✅ `PATCH /suppliers/:id` - Update supplier (with {supplier} format)
    - ✅ `DELETE /suppliers/:id` - Delete supplier (204 no content)
    - **Note**: Uses "Authentication Invalid" message for 401 errors (different from other endpoints)
  - **Authentication endpoints documentation completed** ✅:
    - ✅ `POST /auth/register` - Register new user (with {user, token} format)
    - ✅ `POST /auth/login` - User login (with {user, token} format)
    - ✅ `PATCH /auth/profile` - Update user profile (with {user} format)
    - ✅ `DELETE /auth/profile` - Delete user account (204 no content)
  - Response format: Success returns appropriate object structure, errors return `{msg: <message>}`
  - All protected endpoints include JWT authentication requirement

✅ **All development completed**:
- **Variant-Suppliers CRUD endpoints documentation completed** ✅:
  - ✅ `GET /suppliers/:supplierId/variants` - Get variants for a supplier (for purchasing workflow)
  - ✅ `POST /variant-suppliers/` - Create variant-supplier relationship
  - ✅ `GET /variant-suppliers/:id` - Get specific relationship
  - ✅ `PATCH /variant-suppliers/:id` - Update price/primary supplier status
  - ✅ `DELETE /variant-suppliers/:id` - Delete relationship

## Multi-Tenant Architecture

### Fundamental Principle
**ALL tables (except `users`) include `user_id` as foreign key** to ensure each tenant (user) can only access their own data.

### Multi-Tenant Security Implementation
```sql
-- Example of secure query that always includes user_id
SELECT * FROM products WHERE user_id = :current_user_id AND id = :product_id;

-- Relationships also respect the tenant
SELECT p.*, c.name as category_name 
FROM products p 
JOIN categories c ON c.id = p.category_id 
WHERE p.user_id = :current_user_id AND c.user_id = :current_user_id;
```

### Multi-Tenant Constraints
All tables have constraints that ensure references belong to the same user:

```sql
-- Example in product_variants
CONSTRAINT same_user_check CHECK (
  product_id IN (SELECT id FROM products WHERE user_id = NEW.user_id)
)
```

### Multi-Tenant Data Model
The application uses **multi-tenant** architecture where each user (tenant) has completely isolated data. **All tables include `user_id`** as foreign key to guarantee data isolation.

#### Benefits:
- ✅ **Complete data isolation**: Each user only sees their own data
- ✅ **Scalable for thousands of users**: Architecture prepared to grow
- ✅ **Database-level security**: user_id in all tables prevents cross-access
- ✅ **Referential integrity**: All relationships respect the tenant (user_id)
- ✅ **Automatically filtered queries**: user_id always included in queries

### Table Structure

#### 1. Users
```javascript
{
  id: Integer (PK, Auto-increment)
  email: String (Unique, Required)
  password_hash: String (Required)
  first_name: String (Required)
  last_name: String (Required)
  business_name: String (Optional)
  is_active: Boolean (Default: true)
  email_verified: Boolean (Default: false)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

#### 2. Customers
```javascript
{
  id: Integer (PK, Auto-increment)
  user_id: Integer (FK -> users.id, Required)
  first_name: String (Required)
  last_name: String (Required)
  company: String (Optional)
  phone: String (Optional)
  email: String (Required)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Unique constraint per user
  UNIQUE(user_id, email)
}
```

#### 3. Suppliers
```javascript
{
  id: Integer (PK, Auto-increment)
  user_id: Integer (FK -> users.id, Required)
  first_name: String (Required)
  last_name: String (Required)
  company: String (Optional)
  phone: String (Optional)
  email: String (Required)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Unique constraint per user
  UNIQUE(user_id, email)
}
```

#### 4. Categories (Self-referential)
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  name: String (Required)
  description: String (Optional)
  parent_id: Integer (FK -> categories.id, Optional)
  level: Integer (Default: 0, 0=root, 1=subcategory, etc.)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

**Hierarchy example:**
```
id=1, name="Beer Supplies", parent_id=null, level=0
id=2, name="Hops", parent_id=1, level=1
id=3, name="American Hops", parent_id=2, level=2
id=4, name="Malts", parent_id=1, level=1
```

#### 5. Products
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  name: String (Required)
  description: String (Optional)
  selling_price: Decimal (Required) // Selling price - @db.Decimal(10, 2)
  category_id: Integer (FK -> categories.id)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

#### 6. Product_Variants
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  product_id: Integer (FK -> products.id)
  variant_name: String (Required) // "Default" for products without variants
  is_default: Boolean (Default: false) // Reliable default variant identifier
  selling_price_modifier: Decimal (Default: 0) // +/- on selling_price - @db.Decimal(10, 2)
  stock: Integer (Default: 0) // ONLY place where stock is managed
  attributes: Json (Optional) // Custom attributes
  min_stock_alert: Integer (Default: 0) // Minimum stock alert
  enable_stock_alerts: Boolean (Default: true)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Note: Unique constraint for is_default must be implemented at application level
  // since PostgreSQL doesn't support partial unique constraints with Prisma
}
```

**Use cases**:
- **Simple product**: variant_name = "Default", handles product stock
- **Product with variants**: Each variant (size, color, etc.) with independent stock

#### 7. Variant_Suppliers
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  variant_id: Integer (FK -> product_variants.id)
  supplier_id: Integer (FK -> suppliers.id)
  purchase_price: Decimal (Required) // Purchase price - @db.Decimal(10, 2)
  is_primary_supplier: Boolean (Default: false)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Unique constraint: one supplier per variant per user
  UNIQUE(user_id, variant_id, supplier_id)
}
```

## Important Design Decisions

### 1. Separate Tables for Customers and Suppliers
**Decision**: Create separate `customers` and `suppliers` tables with identical structure.

**Benefits**:
- ✅ Clear separation of responsibilities
- ✅ Immediate identification of contact role
- ✅ Allows different business logic in the future
- ✅ Scalability to add specific fields

### 2. Stock Control Only in Variants
**Decision**: Stock is managed exclusively at product variant level.

**Implementation**:
- **Products WITHOUT variants**: A **DEFAULT variant** is automatically created
- **Products WITH variants**: Each variant manages its own stock
- Default variant allows defining stock and minimum stock for simple products

**Rationale**:
- Consistency: all stock logic is centralized in `product_variants`
- Flexibility: allows evolution from simple product to product with variants
- Simplicity: single place to query stock regardless of product type

### 3. Self-referential Category Hierarchy
**Decision**: Use self-referential table for categories with multiple levels.

**Benefits**:
- ✅ Complete flexibility in structure
- ✅ Support for unlimited nested categories
- ✅ Easy navigation and organization

### 4. Multiple Suppliers per Variant
**Decision**: Allow multiple suppliers per variant with different prices.

**Benefits**:
- ✅ Price comparison
- ✅ Backup suppliers
- ✅ Cost optimization

### 5. Authentication and Authorization
**Decision**: Complete JWT implementation with protection on all routes except auth.

**Implementation**:
- **Public routes**: Only `POST /auth/login` and `POST /auth/register`
- **Protected routes**: All others (including user profile management)
- **Profile routes**: `PATCH /auth/profile` and `DELETE /auth/profile` for better security
- **Middleware**: Automatic user_id extraction from JWT token
- **Multi-tenant security**: user_id always validated in each operation

### 6. Query Optimization for findAll Products
**Decision**: Use raw SQL with JSON aggregation for maximum performance.

**Implementation**:
- Raw SQL query for findAll (critical performance with many products)
- Prisma for findById (less critical, more readable)
- Consistent format between both endpoints
- Explicit cast to avoid BigInt serialization errors
- JSON aggregation to include variants in single query

**Benefits**:
- ✅ **Performance**: Single query vs multiple roundtrips
- ✅ **Consistency**: Same response format in findAll and findById
- ✅ **Scalability**: Optimized to handle large product volumes
- ✅ **Maintainability**: Clear and documented structure

### 7. Unified Response Format for Prices
**Decision**: Convert all Decimal fields to Number in API responses.

**Implementation**:
- Middleware/utility to convert `selling_price`, `selling_price_modifier`, `purchase_price` from string to number
- Swagger schema updated with 'number' type for all prices
- Total consistency between database (Decimal) and API (Number)

**Rationale**:
- ✅ **Improved UX**: Frontend receives numbers directly
- ✅ **Precision maintained**: Database still uses Decimal
- ✅ **Consistency**: All endpoints return the same format
- ✅ **Compatibility**: Works perfectly with JSON and JavaScript

### 8. Complete API Documentation with Swagger
**Decision**: Implement comprehensive Swagger documentation for all endpoints.

**Implementation**:
- Detailed schemas for all entities (Product, ProductVariant, Agenda, Category, User, VariantSupplier, Error)
- Complete endpoint documentation with authentication, validation, and error handling
- Practical examples and realistic data
- Consistent English documentation
- Proper data types (number for prices, not float/string)
- **swagger-jsdoc format** for better code organization and maintainability

**Benefits**:
- ✅ **Developer Experience**: Clear API contract and examples
- ✅ **Frontend Integration**: Precise schema for client generation
- ✅ **Testing**: Easy endpoint testing with Swagger UI
- ✅ **Documentation**: Self-documenting API with up-to-date examples
- ✅ **Maintainability**: Documentation close to route definitions

### 9. Profile-based User Management
**Decision**: Use `/auth/profile` routes instead of `/users/:id` for user operations.

**Implementation**:
- `PATCH /auth/profile` - Update current user's profile
- `DELETE /auth/profile` - Delete current user's account
- user_id automatically extracted from JWT token

**Benefits**:
- ✅ **Enhanced Security**: No risk of ID manipulation in URLs
- ✅ **Simplified Frontend**: No need to track user IDs
- ✅ **Better UX**: Clear semantic meaning ("my profile")
- ✅ **Reduced Complexity**: Less validation logic needed

### 10. Advanced Pagination System
**Decision**: Implement comprehensive pagination with search and sorting for all list endpoints.

**Implementation**:
- **Complete pagination metadata**: 10 fields including currentPage, totalPages, totalItems, itemsPerPage, hasNextPage, hasPreviousPage, nextPage, previousPage, startItem, endItem
- **Search functionality**: Generic search across relevant fields (name, email, company, etc.)
- **Flexible sorting**: sortBy any field, sortOrder (asc/desc) with sensible defaults
- **Performance limits**: Maximum 100 items per page to prevent performance issues
- **Applied to**: GET /products, /customers, /suppliers, /variants endpoints

**Benefits**:
- ✅ **Improved Performance**: Controlled data loading prevents overwhelming responses
- ✅ **Better UX**: Users can find data quickly with search and sorting
- ✅ **Scalability**: Handles thousands of records efficiently
- ✅ **Consistent Interface**: Same pagination format across all entities
- ✅ **Complete Metadata**: Frontend gets all information needed for pagination UI
- ✅ **Flexibility**: Supports various sorting and filtering requirements

## Business Logic: Products and Variants

### Flow for Products Without Variants
1. **Product creation**: Created normally
2. **Automatic variant**: System creates a variant with:
   - `variant_name = "Default"`
   - `selling_price_modifier = 0`
   - `is_default = true`
   - `stock` and `min_stock_alert` defined by user (default 0)
3. **Stock management**: All stock is managed in default variant

### Flow for Products With Variants
1. **Product creation**: Created normally
2. **Custom variants**: User creates specific variants:
   - Example: "Size S", "Size M", "Size L"
   - Each with `is_default = false`
   - Independent stock and alerts (default stock 0)
3. **Distributed stock**: Each variant manages its own inventory

### Frontend has_variants Calculation
**Decision**: Remove `has_variants` from backend and calculate it on client.

```javascript
// In frontend
const hasVariants = product.variants.some(variant => !variant.is_default);
```

**Advantages**:
- ✅ Simpler and faster query
- ✅ Less data redundancy
- ✅ Trivial logic easy to implement on client

### Unified Response Format

Both `findAll` and `findById` return the same format with **default variant always included**:

#### Product WITH custom variants:
```json
{
    "id": 12,
    "name": "Product1",
    "selling_price": 100.00,
    "description": null,
    "category": {
        "id": 4,
        "name": "Category1"
    },
    "created_at": "2025-08-12T22:01:33.012Z",
    "updated_at": "2025-08-12T22:01:33.012Z",
    "variants": [
        {
            "id": 11,
            "variant_name": "Size S",
            "stock": 25,
            "selling_price_modifier": 0.00,
            "min_stock_alert": 5,
            "enable_stock_alerts": true,
            "is_default": false,
            "attributes": null
        },
        {
            "id": 12,
            "variant_name": "Size M", 
            "stock": 1,
            "selling_price_modifier": 10.00,
            "min_stock_alert": 3,
            "enable_stock_alerts": true,
            "is_default": false,
            "attributes": null
        }
    ],
    "total_stock": 26
}
```

#### Product WITHOUT custom variants (only default):
```json
{
    "id": 15,
    "name": "Simple Product",
    "selling_price": 50.00,
    "description": null,
    "category": {
        "id": 4,
        "name": "Category1"
    },
    "created_at": "2025-08-12T22:01:33.012Z",
    "updated_at": "2025-08-12T22:01:33.012Z",
    "variants": [
        {
            "id": 20,
            "variant_name": "Default",
            "stock": 100,
            "selling_price_modifier": 0.00,
            "min_stock_alert": 10,
            "enable_stock_alerts": true,
            "is_default": true,
            "attributes": null
        }
    ],
    "total_stock": 100
}
```

### Advantages of This Approach
✅ **Absolute consistency**: Always query stock in `product_variants`, even for "simple" products
✅ **Scalability**: Easy migration from simple product to product with variants
✅ **Flexibility**: Different prices, stock and alerts per variant
✅ **Simplicity in queries**: Single place to get stock information
✅ **Unified format**: Same structure in all endpoints
✅ **Centralized logic**: No special cases for products "without variants"

### Practical Example
```sql
-- Get total stock for a product (with or without variants)
SELECT SUM(pv.stock) as total_stock
FROM product_variants pv 
WHERE pv.product_id = :product_id AND pv.user_id = :user_id;

-- Get products with low stock
SELECT p.name, pv.variant_name, pv.stock, pv.min_stock_alert
FROM products p
JOIN product_variants pv ON p.id = pv.product_id
WHERE pv.stock <= pv.min_stock_alert 
  AND pv.enable_stock_alerts = true
  AND p.user_id = :user_id;

-- Determine if a product has custom variants
SELECT p.*, 
       CASE WHEN EXISTS(
         SELECT 1 FROM product_variants pv 
         WHERE pv.product_id = p.id AND pv.is_default = false
       ) THEN true ELSE false END as has_variants
FROM products p 
WHERE p.user_id = :user_id;
```

## API Documentation Progress

### ✅ **Completed Documentation**:

#### **Core Entities**:
- Products CRUD (5 endpoints) - **with advanced pagination**
- Product Variants CRUD (5 endpoints) - **with advanced pagination**
- Categories CRUD (5 endpoints)
- Customers CRUD (5 endpoints) - **with advanced pagination**
- Suppliers CRUD (5 endpoints) - **with advanced pagination**
- Authentication (4 endpoints)
- Variant-Suppliers CRUD (5 endpoints)

#### **Total Documented**: **34/34 endpoints** 🎉

### **Advanced Pagination Features**:
- **4 endpoints with full pagination**: Products, Variants, Customers, Suppliers
- **Complete metadata**: 10 pagination fields for optimal UX
- **Search functionality**: Cross-field search capability
- **Flexible sorting**: sortBy field + sortOrder direction
- **Performance optimized**: Max 100 items per page limit
- **Query parameters**: page, limit, search, sortBy, sortOrder

### **Pagination Response Format**:
```json
{
  "products": [...], // or customers, suppliers, variants
  "pagination": {
    "currentPage": 1,
    "totalPages": 5,
    "totalItems": 48,
    "itemsPerPage": 10,
    "hasNextPage": true,
    "hasPreviousPage": false,
    "nextPage": 2,
    "previousPage": null,
    "startItem": 1,
    "endItem": 10
  }
}
```

### **🏆 API Documentation: 100% Complete with Advanced Pagination**

All endpoints have been documented with:
✅ Complete swagger-jsdoc format
✅ Advanced pagination schemas and parameters
✅ Realistic examples and data
✅ Consistent response formats
✅ Proper authentication requirements
✅ Comprehensive error handling
✅ Detailed request/response schemas
✅ Consistent English descriptions
✅ Search and sorting capabilities