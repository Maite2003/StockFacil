# StockFacil - Complete Project Documentation

## General Project Information

### Description
**StockFacil** is a comprehensive web application for inventory, customer and supplier management for businesses. It allows companies to maintain complete control over their stock, prices, commercial relationships and product structure with variants.

### Application Type
- **Frontend**: Web Application
- **Backend**: REST API 
- **Database**: PostgreSQL with Prisma ORM

### Current Development Status
✅ **Completed**:
- Database schema defined
- Prisma schema configured
- CRUD routes implemented for:
  - Users
  - Customers
  - Suppliers
  - Categories
  - Products
  - Product variants
  - **Variant-Suppliers** (variant-supplier relationship):
    - `GET /suppliers/:supplierId/variants` - Get variants from a supplier
    - `POST /variant-suppliers/` - Create variant-supplier relationship
    - `GET /variant-suppliers/:id` - Get specific relationship
    - `PATCH /variant-suppliers/:id` - Update price/primary supplier
    - `DELETE /variant-suppliers/:id` - Delete relationship
- Validations with express-validator implemented
- **JWT Authentication implemented**:
  - Login and register (public routes)
  - **🆕 Email verification system with Nodemailer OAuth2**:
    - `POST /auth/send-verification` - Send/resend verification email
    - `GET /auth/verify-email/:token` - Verify email with token
    - `GET /auth/verification-status` - Check verification status
    - Email verification tokens with 24-hour expiration
    - **Gmail OAuth2 integration** with Nodemailer (completely free, production-ready)
    - HTML email templates with verification links
    - Express 5 compatible implementation
    - Graceful error handling when email service is not configured
  - All other routes require authentication (including user update)
  - Authorization middleware configured
  - Automatic user_id extraction from token
- **Optimized query for findAll products**:
  - Raw SQL with performance optimization for listings
  - Consistent format with findById
  - JSON aggregation for variants
  - Explicit casting to avoid BigInt serialization errors
- **Unified response format**:
  - Automatic Decimal to Number conversion in responses
  - Swagger schema updated with 'number' type for prices
  - Total consistency between findAll and findById
- **🆕 Advanced Pagination System**:
  - Complete pagination with metadata (currentPage, totalPages, totalItems, etc.)
  - Search functionality across relevant fields
  - Flexible sorting (sortBy field, sortOrder asc/desc)
  - Query parameters: page, limit, search, sortBy, sortOrder
  - Implemented in GET /products, /customers, /suppliers, /variants endpoints
  - Maximum 100 items per page for performance
- **🆕 API Documentation with Swagger**:
  - Complete schemas defined (Product, ProductVariant, Agenda, Category, User, VariantSupplier, Error)
  - **New Pagination Schemas**:
    - `Pagination` - Complete pagination metadata with 10 fields
    - `PaginatedProductsResponse` - Products with pagination
    - `PaginatedCustomersResponse` - Customers with pagination  
    - `PaginatedSuppliersResponse` - Suppliers with pagination
    - `PaginatedVariantsResponse` - Variants with pagination
  - **New Query Parameters**:
    - `PageParam` - Page number (1-based, default 1)
    - `LimitParam` - Items per page (1-100, default 10)
    - `SearchParam` - Search term filter
    - `SortByParam` - Field to sort by
    - `SortOrderParam` - Sort direction (asc/desc)
  - **Products CRUD endpoints documentation completed** ✅:
    - ✅ `POST /products` - Create new product (completed with specific response format)
    - ✅ `GET /products` - Get all products **with pagination, search & sorting** (completed with {products, pagination} format)
    - ✅ `GET /products/:id` - Get product by ID (completed with {product} format)
    - ✅ `PATCH /products/:id` - Update product (completed with {product} format)
    - ✅ `DELETE /products/:id` - Delete product (completed with 204 no content)
  - **Product Variants CRUD endpoints documentation completed** ✅:
    - ✅ `GET /products/:productId/variants` - Get all variants **with pagination, search & sorting** (with {variants, pagination} format)
    - ✅ `POST /products/:productId/variants` - Create new variant (with {variant} format)
    - ✅ `GET /products/:productId/variants/:id` - Get variant by ID (with {variant} format)
    - ✅ `PATCH /products/:productId/variants/:id` - Update variant (with {variant} format)
    - ✅ `DELETE /products/:productId/variants/:id` - Delete variant (204 no content)
  - **Categories CRUD endpoints documentation completed** ✅:
    - ✅ `GET /categories` - Get all categories (with {categories, length} format)
    - ✅ `POST /categories` - Create new category (with {Category} format)
    - ✅ `GET /categories/:id` - Get category by ID (with {category} format)
    - ✅ `PATCH /categories/:id` - Update category (with {category} format)
    - ✅ `DELETE /categories/:id` - Delete category (204 no content)
  - **Customers CRUD endpoints documentation completed** ✅:
    - ✅ `GET /customers` - Get all customers **with pagination, search & sorting** (with {customers, pagination} format)
    - ✅ `POST /customers` - Create new customer (with {Customer} format)
    - ✅ `GET /customers/:id` - Get customer by ID (with {customer} format)
    - ✅ `PATCH /customers/:id` - Update customer (with {customer} format)
    - ✅ `DELETE /customers/:id` - Delete customer (204 no content)
  - **Suppliers CRUD endpoints documentation completed** ✅:
    - ✅ `GET /suppliers` - Get all suppliers **with pagination, search & sorting** (with {suppliers, pagination} format)
    - ✅ `POST /suppliers` - Create new supplier (with {Supplier} format)
    - ✅ `GET /suppliers/:id` - Get supplier by ID (with {supplier} format)
    - ✅ `PATCH /suppliers/:id` - Update supplier (with {supplier} format)
    - ✅ `DELETE /suppliers/:id` - Delete supplier (204 no content)
    - **Note**: Uses "Authentication Invalid" message for 401 errors (different from other endpoints)
  - **Authentication endpoints documentation completed** ✅:
    - ✅ `POST /auth/register` - Register new user (with {user, token} format)
    - ✅ `POST /auth/login` - User login (with {user, token} format)
    - ✅ `PATCH /auth/profile` - Update user profile (with {user} format)
    - ✅ `DELETE /auth/profile` - Delete user account (204 no content)
    - **🆕 Email Verification Endpoints - Fully Documented with Swagger** ✅:
      - ✅ `POST /auth/send-verification` - Send/resend email verification **with detailed Swagger documentation**:
        - **Authentication**: Required (JWT Bearer token)
        - **Request Body**: No body required
        - **Success Response (204)**: No Content - Verification email sent successfully
        - **Error Responses**: 401 (Unauthorized), 409 (Already verified), 500 (Email service error)
        - **Description**: Generates JWT token with 24h expiration, sends HTML email with verification link using Nodemailer OAuth2
        - **Email Content**: Professional HTML template with StockFacil branding and verification button
        - **Graceful Handling**: Returns success even if email service is misconfigured (logs error internally)
        - **HTTP Semantics**: Uses 204 No Content as no data needs to be returned after successful email send
      - ✅ `GET /auth/verify-email/:token` - Verify email with token **with detailed Swagger documentation**:
        - **Authentication**: None required (public endpoint)
        - **Path Parameter**: `token` (JWT token from email link)
        - **Success Response (204)**: No Content - Email verified successfully
        - **Error Responses**: 400 (Invalid/expired token), 404 (User not found), 500 (Server error)
        - **Description**: Validates JWT token, updates user's email_verified to true, clears verification token from database
        - **Token Validation**: Checks token purpose, expiration, and user existence
        - **Security**: Single-use token (cleared after successful verification)
        - **HTTP Semantics**: Uses 204 No Content as verification action is complete without data to return
      - ✅ `GET /auth/verification-status` - Check email verification status **with detailed Swagger documentation**:
        - **Authentication**: Required (JWT Bearer token)
        - **Request Body**: No body required  
        - **Success Response (200)**: `{email_verified: boolean, email: "user@example.com"}`
        - **Error Responses**: 401 (Unauthorized), 500 (Server error)
        - **Description**: Returns current email verification status for authenticated user
        - **Usage**: Frontend uses this to show verification prompts and update UI state
        - **Real-time Status**: Always reflects current database state
        - **HTTP Semantics**: Uses 200 OK as it returns useful data (verification status and email)
  - Response format: Success returns appropriate object structure, errors return `{msg: <message>}`
  - All protected endpoints include JWT authentication requirement

✅ **All development completed**:
- **Variant-Suppliers CRUD endpoints documentation completed** ✅:
  - ✅ `GET /suppliers/:supplierId/variants` - Get variants for a supplier (for purchasing workflow)
  - ✅ `POST /variant-suppliers/` - Create variant-supplier relationship
  - ✅ `GET /variant-suppliers/:id` - Get specific relationship
  - ✅ `PATCH /variant-suppliers/:id` - Update price/primary supplier status
  - ✅ `DELETE /variant-suppliers/:id` - Delete relationship
- **🆕 Statistics endpoints completed** ✅:
  - ✅ `GET /stats/inventory` - Get inventory statistics (totalProducts, lowStockAlerts, outOfStockItems)
  - ✅ `GET /stats/agenda` - Get agenda statistics (totalCustomers, totalSuppliers)
- **🆕 Utility endpoints completed** ✅:
  - ✅ `GET /` - Root endpoint with API information and docs link
  - ✅ `GET /health` - Health check endpoint with status and environment info
- **🆕 Dynamic Swagger Configuration**:
  - ✅ **Server URLs**: Automatically configured based on NODE_ENV (localhost for development, production URL for production)
  - ✅ **Express 5 Compatibility**: Modern implementation with Nodemailer OAuth2
- **🆕 Production Security implemented** ✅:
  - ✅ **Helmet**: Security headers (XSS, clickjacking, MIME sniffing protection)
  - ✅ **Rate Limiting**: 5 requests/15min for auth, 100 requests/15min for API endpoints
  - ✅ **CORS**: Properly configured for production and development environments
  - ✅ **Input Sanitization**: HTTP parameter pollution prevention (express-mongo-sanitize removed for Express 5 compatibility)
  - ✅ **Environment-based configuration**: Different security settings and **dynamic servers configuration** for production vs development
  - ✅ **Deployed on Render**: https://stockfacil.onrender.com/
  - ✅ **API Documentation**: https://stockfacil.onrender.com/api-docs
  - ✅ **Environment configured**: NODE_ENV=production, PostgreSQL, JWT authentication, **Nodemailer OAuth2**
  - ✅ **Multi-tenant security**: All endpoints properly isolated per user
  - ✅ **Performance optimized**: Raw SQL for stats, pagination limits, database indexing

## Multi-Tenant Architecture

### Fundamental Principle
**ALL tables (except `users`) include `user_id` as foreign key** to ensure each tenant (user) can only access their own data.

### Multi-Tenant Security Implementation
```sql
-- Example of secure query that always includes user_id
SELECT * FROM products WHERE user_id = :current_user_id AND id = :product_id;

-- Relationships also respect the tenant
SELECT p.*, c.name as category_name 
FROM products p 
JOIN categories c ON c.id = p.category_id 
WHERE p.user_id = :current_user_id AND c.user_id = :current_user_id;
```

### Multi-Tenant Constraints
All tables have constraints that ensure references belong to the same user:

```sql
-- Example in product_variants
CONSTRAINT same_user_check CHECK (
  product_id IN (SELECT id FROM products WHERE user_id = NEW.user_id)
)
```

### Multi-Tenant Data Model
The application uses **multi-tenant** architecture where each user (tenant) has completely isolated data. **All tables include `user_id`** as foreign key to guarantee data isolation.

#### Benefits:
- ✅ **Complete data isolation**: Each user only sees their own data
- ✅ **Scalable for thousands of users**: Architecture prepared to grow
- ✅ **Database-level security**: user_id in all tables prevents cross-access
- ✅ **Referential integrity**: All relationships respect the tenant (user_id)
- ✅ **Automatically filtered queries**: user_id always included in queries

### Table Structure

#### 1. Users
```javascript
{
  id: Integer (PK, Auto-increment)
  email: String (Unique, Required)
  password_hash: String (Required)
  first_name: String (Required)
  last_name: String (Required)
  business_name: String (Optional)
  is_active: Boolean (Default: true)
  email_verified: Boolean (Default: false)
  email_verification_token: String (Optional) // JWT token for email verification
  email_verification_expires: DateTime (Optional) // Token expiration (24 hours)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

#### 2. Customers
```javascript
{
  id: Integer (PK, Auto-increment)
  user_id: Integer (FK -> users.id, Required)
  first_name: String (Required)
  last_name: String (Required)
  company: String (Optional)
  phone: String (Optional)
  email: String (Required)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Unique constraint per user
  UNIQUE(user_id, email)
}
```

#### 3. Suppliers
```javascript
{
  id: Integer (PK, Auto-increment)
  user_id: Integer (FK -> users.id, Required)
  first_name: String (Required)
  last_name: String (Required)
  company: String (Optional)
  phone: String (Optional)
  email: String (Required)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Unique constraint per user
  UNIQUE(user_id, email)
}
```

#### 4. Categories (Self-referential)
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  name: String (Required)
  description: String (Optional)
  parent_id: Integer (FK -> categories.id, Optional)
  level: Integer (Default: 0, 0=root, 1=subcategory, etc.)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

**Hierarchy example:**
```
id=1, name="Beer Supplies", parent_id=null, level=0
id=2, name="Hops", parent_id=1, level=1
id=3, name="American Hops", parent_id=2, level=2
id=4, name="Malts", parent_id=1, level=1
```

#### 5. Products
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  name: String (Required)
  description: String (Optional)
  selling_price: Decimal (Required) // Selling price - @db.Decimal(10, 2)
  category_id: Integer (FK -> categories.id)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

#### 6. Product_Variants
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  product_id: Integer (FK -> products.id)
  variant_name: String (Required) // "Default" for products without variants
  is_default: Boolean (Default: false) // Reliable default variant identifier
  selling_price_modifier: Decimal (Default: 0) // +/- on selling_price - @db.Decimal(10, 2)
  stock: Integer (Default: 0) // ONLY place where stock is managed
  attributes: Json (Optional) // Custom attributes
  min_stock_alert: Integer (Default: 0) // Minimum stock alert
  enable_stock_alerts: Boolean (Default: true)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Note: Unique constraint for is_default must be implemented at application level
  // since PostgreSQL doesn't support partial unique constraints with Prisma
}
```

**Use cases**:
- **Simple product**: variant_name = "Default", handles product stock
- **Product with variants**: Each variant (size, color, etc.) with independent stock

#### 7. Variant_Suppliers
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Required)
  variant_id: Integer (FK -> product_variants.id)
  supplier_id: Integer (FK -> suppliers.id)
  purchase_price: Decimal (Required) // Purchase price - @db.Decimal(10, 2)
  is_primary_supplier: Boolean (Default: false)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Unique constraint: one supplier per variant per user
  UNIQUE(user_id, variant_id, supplier_id)
}
```

## Email Verification System with Nodemailer OAuth2

### Configuration Required

#### Environment Variables:
```env
# Email Configuration (Gmail OAuth2)
GMAIL_USER=your-email@gmail.com
GMAIL_CLIENT_ID=your_client_id_from_google_cloud
GMAIL_CLIENT_SECRET=your_client_secret_from_google_cloud
GMAIL_REFRESH_TOKEN=your_refresh_token_from_oauth_playground

# Frontend URL (for verification links)
FRONTEND_URL=https://your-frontend-domain.com
```

### Google OAuth2 Setup Process:
1. **Google Cloud Console**: Create project → Enable Gmail API
2. **OAuth2 Credentials**: Create OAuth2 Client ID (Web application)
3. **OAuth Playground**: Generate refresh token with `https://mail.google.com/` scope
4. **Test Users**: Add test users in OAuth consent screen (for development)

### Email Service Features:
- ✅ **Graceful configuration handling**: App starts even if email env vars are missing
- ✅ **Professional HTML templates**: Responsive design with StockFacil branding
- ✅ **JWT token security**: 24-hour expiration with email verification purpose
- ✅ **Connection verification**: Built-in health check for OAuth2 setup
- ✅ **Error handling**: Detailed error messages and logging
- ✅ **Test email capability**: Built-in method for testing configuration

### Email Verification Flow:
1. **User Registration**: Created with `email_verified = false`
2. **Send Verification**: `POST /auth/send-verification` generates JWT token and sends email
3. **User Clicks Link**: Email contains verification URL with token
4. **Email Verified**: `GET /auth/verify-email/:token` validates and sets `email_verified = true`
5. **Status Check**: `GET /auth/verification-status` allows frontend to check status

### Dependencies:
```json
{
  "nodemailer": "^6.9.7"
}
```

## Important Design Decisions

### 1. Separate Tables for Customers and Suppliers
**Decision**: Create separate `customers` and `suppliers` tables with identical structure.

**Benefits**:
- ✅ Clear separation of responsibilities
- ✅ Immediate identification of contact role
- ✅ Allows different business logic in the future
- ✅ Scalability to add specific fields

### 2. Stock Control Only in Variants
**Decision**: Stock is managed exclusively at product variant level.

**Implementation**:
- **Products WITHOUT variants**: A **DEFAULT variant** is automatically created
- **Products WITH variants**: Each variant manages its own stock
- Default variant allows defining stock and minimum stock for simple products

**Rationale**:
- Consistency: all stock logic is centralized in `product_variants`
- Flexibility: allows evolution from simple product to product with variants
- Simplicity: single place to query stock regardless of product type

### 3. Self-referential Category Hierarchy
**Decision**: Use self-referential table for categories with multiple levels.

**Benefits**:
- ✅ Complete flexibility in structure
- ✅ Support for unlimited nested categories
- ✅ Easy navigation and organization

### 4. Multiple Suppliers per Variant
**Decision**: Allow multiple suppliers per variant with different prices.

**Benefits**:
- ✅ Price comparison
- ✅ Backup suppliers
- ✅ Cost optimization

### 5. Authentication and Authorization
**Decision**: Complete JWT implementation with protection on all routes except auth.

**Implementation**:
- **Public routes**: Only `POST /auth/login`, `POST /auth/register`, and `GET /auth/verify-email/:token`
- **Protected routes**: All others (including user profile management)
- **Profile routes**: `PATCH /auth/profile` and `DELETE /auth/profile` for better security
- **Middleware**: Automatic user_id extraction from JWT token
- **Multi-tenant security**: user_id always validated in each operation

### 6. Query Optimization for findAll Products
**Decision**: Use raw SQL with JSON aggregation for maximum performance.

**Implementation**:
- Raw SQL query for findAll (critical performance with many products)
- Prisma for findById (less critical, more readable)
- Consistent format between both endpoints
- Explicit cast to avoid BigInt serialization errors
- JSON aggregation to include variants in single query

**Benefits**:
- ✅ **Performance**: Single query vs multiple roundtrips
- ✅ **Consistency**: Same response format in findAll and findById
- ✅ **Scalability**: Optimized to handle large product volumes
- ✅ **Maintainability**: Clear and documented structure

### 7. Unified Response Format for Prices
**Decision**: Convert all Decimal fields to Number in API responses.

**Implementation**:
- Middleware/utility to convert `selling_price`, `selling_price_modifier`, `purchase_price` from string to number
- Swagger schema updated with 'number' type for all prices
- Total consistency between database (Decimal) and API (Number)

**Rationale**:
- ✅ **Improved UX**: Frontend receives numbers directly
- ✅ **Precision maintained**: Database still uses Decimal
- ✅ **Consistency**: All endpoints return the same format
- ✅ **Compatibility**: Works perfectly with JSON and JavaScript

### 8. Complete API Documentation with Swagger
**Decision**: Implement comprehensive Swagger documentation for all endpoints.

**Implementation**:
- Detailed schemas for all entities (Product, ProductVariant, Agenda, Category, User, VariantSupplier, Error)
- Complete endpoint documentation with authentication, validation, and error handling
- Practical examples and realistic data
- Consistent English documentation
- Proper data types (number for prices, not float/string)
- **swagger-jsdoc format** for better code organization and maintainability
- **🆕 Detailed Email Verification Documentation**: Complete Swagger specs for all 3 email verification endpoints with request/response examples, authentication requirements, error codes, and detailed descriptions

**Benefits**:
- ✅ **Developer Experience**: Clear API contract and examples
- ✅ **Frontend Integration**: Precise schema for client generation
- ✅ **Testing**: Easy endpoint testing with Swagger UI
- ✅ **Documentation**: Self-documenting API with up-to-date examples
- ✅ **Maintainability**: Documentation close to route definitions
- ✅ **Email Verification**: Complete documentation for email workflow implementation

### 9. Profile-based User Management
**Decision**: Use `/auth/profile` routes instead of `/users/:id` for user operations.

**Implementation**:
- `PATCH /auth/profile` - Update current user's profile
- `DELETE /auth/profile` - Delete current user's account
- user_id automatically extracted from JWT token

**Benefits**:
- ✅ **Enhanced Security**: No risk of ID manipulation in URLs
- ✅ **Simplified Frontend**: No need to track user IDs
- ✅ **Better UX**: Clear semantic meaning ("my profile")
- ✅ **Reduced Complexity**: Less validation logic needed

### 10. Advanced Pagination System
**Decision**: Implement comprehensive pagination with search and sorting for all list endpoints.

**Implementation**:
- **Complete pagination metadata**: 10 fields including currentPage, totalPages, totalItems, itemsPerPage, hasNextPage, hasPreviousPage, nextPage, previousPage, startItem, endItem
- **Search functionality**: Generic search across relevant fields (name, email, company, etc.)
- **Flexible sorting**: sortBy any field, sortOrder (asc/desc) with sensible defaults
- **Performance limits**: Maximum 100 items per page to prevent performance issues
- **Applied to**: GET /products, /customers, /suppliers, /variants endpoints

**Benefits**:
- ✅ **Improved Performance**: Controlled data loading prevents overwhelming responses
- ✅ **Better UX**: Users can find data quickly with search and sorting
- ✅ **Scalability**: Handles thousands of records efficiently
- ✅ **Consistent Interface**: Same pagination format across all entities
- ✅ **Complete Metadata**: Frontend gets all information needed for pagination UI
- ✅ **Flexibility**: Supports various sorting and filtering requirements

### 11. Email Verification System with Nodemailer OAuth2
**Decision**: Implement complete email verification using Gmail OAuth2 with Nodemailer for production-ready, free email service.

**Implementation**:
- `POST /auth/send-verification` - Send/resend verification email to authenticated user (204 No Content)
- `GET /auth/verify-email/:token` - Verify email using JWT token from email link (204 No Content)
- `GET /auth/verification-status` - Check current verification status for authenticated user (200 with data)
- JWT tokens for email verification with 24-hour expiration
- Database fields: `email_verification_token`, `email_verification_expires`
- **Nodemailer with Gmail OAuth2** - Direct implementation with graceful error handling
- HTML email templates with professional design and StockFacil branding
- API link verification with proper success/error handling
- **🆕 Complete Swagger Documentation**: All 3 email verification endpoints fully documented with detailed request/response schemas, authentication requirements, error handling, and practical examples
- **🆕 HTTP Semantics**: Proper use of 204 No Content for actions without return data, 200 OK for data responses

**Gmail OAuth2 Configuration**:
- **Environment Variables**: `GMAIL_USER`, `GMAIL_CLIENT_ID`, `GMAIL_CLIENT_SECRET`, `GMAIL_REFRESH_TOKEN`
- **Dependencies**: Only `nodemailer` (modern, maintained library)
- **OAuth2 Setup**: Google Cloud Console → Gmail API → OAuth2 credentials → Refresh token
- **Express 5 Compatible**: Modern implementation without deprecated libraries

**Benefits**:
- ✅ **Completely Free**: Gmail OAuth2 with no production limits
- ✅ **High Deliverability**: Gmail service ensures emails reach inbox
- ✅ **Production Ready**: OAuth2 authentication with proper token management
- ✅ **Modern Implementation**: Only maintained dependencies, Express 5 compatible
- ✅ **Graceful Degradation**: App runs even if email service is misconfigured
- ✅ **Security**: JWT tokens with purpose validation and expiration
- ✅ **Professional**: HTML email templates with responsive design
- ✅ **Developer Friendly**: Built-in testing methods and connection verification
- ✅ **Fully Documented**: Complete Swagger documentation for all email verification endpoints
- ✅ **HTTP Standards Compliant**: Uses 204 No Content for actions, 200 OK for data responses

## Business Logic: Products and Variants

### Flow for Products Without Variants
1. **Product creation**: Created normally
2. **Automatic variant**: System creates a variant with:
   - `variant_name = "Default"`
   - `selling_price_modifier = 0`
   - `is_default = true`
   - `stock` and `min_stock_alert` defined by user (default 0)
3. **Stock management**: All stock is managed in default variant

### Flow for Products With Variants
1. **Product creation**: Created normally
2. **Custom variants**: User creates specific variants:
   - Example: "Size S", "Size M", "Size L"
   - Each with `is_default = false`
   - Independent stock and alerts (default stock 0)
3. **Distributed stock**: Each variant manages its own inventory

### Frontend has_variants Calculation
**Decision**: Remove `has_variants` from backend and calculate it on client.

```javascript
// In frontend
const hasVariants = product.variants.some(variant => !variant.is_default);
```

**Advantages**:
- ✅ Simpler and faster query
- ✅ Less data redundancy
- ✅ Trivial logic easy to implement on client

### Unified Response Format

Both `findAll` and `findById` return the same format with **default variant always included**:

#### Product WITH custom variants:
```json
{
    "id": 12,
    "name": "Product1",
    "selling_price": 100.00,
    "description": null,
    "category": {
        "id": 4,
        "name": "Category1"
    },
    "created_at": "2025-08-12T22:01:33.012Z",
    "updated_at": "2025-08-12T22:01:33.012Z",
    "variants": [
        {
            "id": 11,
            "variant_name": "Size S",
            "stock": 25,
            "selling_price_modifier": 0.00,
            "min_stock_alert": 5,
            "enable_stock_alerts": true,
            "is_default": false,
            "attributes": null
        },
        {
            "id": 12,
            "variant_name": "Size M", 
            "stock": 1,
            "selling_price_modifier": 10.00,
            "min_stock_alert": 3,
            "enable_stock_alerts": true,
            "is_default": false,
            "attributes": null
        }
    ],
    "total_stock": 26
}
```

#### Product WITHOUT custom variants (only default):
```json
{
    "id": 15,
    "name": "Simple Product",
    "selling_price": 50.00,
    "description": null,
    "category": {
        "id": 4,
        "name": "Category1"
    },
    "created_at": "2025-08-12T22:01:33.012Z",
    "updated_at": "2025-08-12T22:01:33.012Z",
    "variants": [
        {
            "id": 20,
            "variant_name": "Default",
            "stock": 100,
            "selling_price_modifier": 0.00,
            "min_stock_alert": 10,
            "enable_stock_alerts": true,
            "is_default": true,
            "attributes": null
        }
    ],
    "total_stock": 100
}
```

### Advantages of This Approach
✅ **Absolute consistency**: Always query stock in `product_variants`, even for "simple" products
✅ **Scalability**: Easy migration from simple product to product with variants
✅ **Flexibility**: Different prices, stock and alerts per variant
✅ **Simplicity in queries**: Single place to get stock information
✅ **Unified format**: Same structure in all endpoints
✅ **Centralized logic**: No special cases for products "without variants"

### Practical Example
```sql
-- Get total stock for a product (with or without variants)
SELECT SUM(pv.stock) as total_stock
FROM product_variants pv 
WHERE pv.product_id = :product_id AND pv.user_id = :user_id;

-- Get products with low stock
SELECT p.name, pv.variant_name, pv.stock, pv.min_stock_alert
FROM products p
JOIN product_variants pv ON p.id = pv.product_id
WHERE pv.stock <= pv.min_stock_alert 
  AND pv.enable_stock_alerts = true
  AND p.user_id = :user_id;

-- Determine if a product has custom variants
SELECT p.*, 
       CASE WHEN EXISTS(
         SELECT 1 FROM product_variants pv 
         WHERE pv.product_id = p.id AND pv.is_default = false
       ) THEN true ELSE false END as has_variants
FROM products p 
WHERE p.user_id = :user_id;
```

## API Documentation Progress

### ✅ **Completed Documentation**:

#### **Core Entities**:
- Products CRUD (5 endpoints) - **with advanced pagination**
- Product Variants CRUD (5 endpoints) - **with advanced pagination**
- Categories CRUD (5 endpoints)
- Customers CRUD (5 endpoints) - **with advanced pagination**
- Suppliers CRUD (5 endpoints) - **with advanced pagination**
- Authentication (7 endpoints) - **with Nodemailer OAuth2 email verification system**
- Variant-Suppliers CRUD (5 endpoints)

#### **🆕 Email Verification Endpoints - Complete Swagger Documentation**:
All 3 email verification endpoints now have **comprehensive Swagger documentation**:

1. **POST /auth/send-verification**:
   - ✅ **Complete request/response schemas** with examples
   - ✅ **Authentication requirements** (JWT Bearer token)
   - ✅ **Error handling documentation** (401, 409, 500)
   - ✅ **Detailed description** including Nodemailer OAuth2 implementation
   - ✅ **Response format**: `{message: "Verification email sent successfully"}`

2. **GET /auth/verify-email/:token**:
   - ✅ **Path parameter schema** for JWT token
   - ✅ **Public endpoint documentation** (no authentication required)
   - ✅ **Success response schema** with user object
   - ✅ **Error scenarios** (400 invalid token, 404 user not found, 500 server error)
   - ✅ **Token validation description** and single-use security

3. **GET /auth/verification-status**:
   - ✅ **Authentication requirements** (JWT Bearer token)
   - ✅ **Response schema** with email_verified boolean and email
   - ✅ **Error handling** (401, 500)
   - ✅ **Usage description** for frontend integration

#### **Total Documented**: **42/42 endpoints** 🎉

### **Statistics Endpoints**:
- GET /stats/inventory - **Inventory statistics** (products count, low stock alerts, out of stock items)
- GET /stats/agenda - **Agenda statistics** (customers count, suppliers count)

### **Utility Endpoints**:
- GET / - **Root endpoint** (API information and documentation link)
- GET /health - **Health check** (status, timestamp, environment)

### **Advanced Pagination Features**:
- **4 endpoints with full pagination**: Products, Variants, Customers, Suppliers
- **Complete metadata**: 10 pagination fields for optimal UX
- **Search functionality**: Cross-field search capability
- **Flexible sorting**: sortBy field + sortOrder direction
- **Performance optimized**: Max 100 items per page limit
- **Query parameters**: page, limit, search, sortBy, sortOrder

### **Pagination Response Format**:
```json
{
  "products": [...], // or customers, suppliers, variants
  "pagination": {
    "currentPage": 1,
    "totalPages": 5,
    "totalItems": 48,
    "itemsPerPage": 10,
    "hasNextPage": true,
    "hasPreviousPage": false,
    "nextPage": 2,
    "previousPage": null,
    "startItem": 1,
    "endItem": 10
  }
}
```

### **🏆 API Documentation: 100% Complete with Production Deployment**

All endpoints have been documented with:
✅ Complete swagger-jsdoc format
✅ Advanced pagination schemas and parameters
✅ **🆕 Complete Email Verification Documentation** - All 3 endpoints fully documented with detailed schemas
✅ **Nodemailer OAuth2 email verification system** for secure user authentication
✅ Statistics endpoints for inventory and agenda management
✅ Utility endpoints for health monitoring and API information
✅ Production deployment on Render with full environment configuration
✅ Realistic examples and data
✅ Consistent response formats
✅ Proper authentication requirements
✅ Comprehensive error handling
✅ Detailed request/response schemas
✅ Consistent English descriptions
✅ Search and sorting capabilities

## Production Configuration

### Environment Variables for Production:
```env
# Database
DATABASE_URL=your_production_database_url

# JWT
JWT_SECRET=your_secure_jwt_secret

# Server
PORT=3000
NODE_ENV=production

# Email Configuration (Gmail OAuth2)
GMAIL_USER=your-business-email@gmail.com
GMAIL_CLIENT_ID=your_google_cloud_client_id
GMAIL_CLIENT_SECRET=your_google_cloud_client_secret
GMAIL_REFRESH_TOKEN=your_oauth2_refresh_token

# Frontend URL
FRONTEND_URL=https://your-frontend-domain.com
```

### Deployment Checklist:
- ✅ PostgreSQL database configured
- ✅ All environment variables set
- ✅ Gmail OAuth2 credentials configured
- ✅ SSL/HTTPS enabled
- ✅ CORS properly configured
- ✅ Rate limiting enabled
- ✅ Security headers (Helmet) active
- ✅ API documentation accessible
- ✅ Health check endpoint working
- ✅ Multi-tenant security verified
- ✅ **Email verification system fully functional with Nodemailer OAuth2**
- ✅ **All 42 endpoints documented in Swagger with complete schemas**