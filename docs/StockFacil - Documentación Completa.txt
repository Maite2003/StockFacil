# StockFacil - Documentaci√≥n Completa del Proyecto

## Informaci√≥n General del Proyecto

### Descripci√≥n
**StockFacil** es una aplicaci√≥n web para la gesti√≥n integral de inventarios, clientes y proveedores de empresas. Permite a las empresas mantener control completo sobre su stock, precios, relaciones comerciales y estructura de productos con variantes.

### Tipo de Aplicaci√≥n
- **Frontend**: Aplicaci√≥n Web
- **Backend**: API REST 
- **Base de Datos**: PostgreSQL con Prisma ORM

### Estado Actual del Desarrollo
‚úÖ **Completado**:
- Esquema de base de datos definido
- Schema de Prisma configurado
- Rutas CRUD implementadas para:
  - Usuarios
  - Clientes
  - Proveedores
  - Categor√≠as
  - Productos
  - Variantes de productos
  - **Variant-Suppliers** (relaci√≥n variantes-proveedores):
    - `GET /suppliers/:supplierId/variants` - Obtener variantes de un proveedor
    - `POST /variant-suppliers/` - Crear relaci√≥n variant-supplier
    - `GET /variant-suppliers/:id` - Obtener relaci√≥n espec√≠fica
    - `PATCH /variant-suppliers/:id` - Actualizar precio/proveedor principal
    - `DELETE /variant-suppliers/:id` - Eliminar relaci√≥n
- Validaciones con express-validator implementadas
- **Autenticaci√≥n JWT implementada**:
  - Login y register (rutas p√∫blicas)
  - Todas las dem√°s rutas requieren autenticaci√≥n (incluyendo update de usuario)
  - Middleware de autorizaci√≥n configurado
  - Extracci√≥n autom√°tica de user_id del token
- **Query optimizada para findAll productos**:
  - Raw SQL con performance optimizada para listados
  - Formato consistente con findById
  - JSON aggregation para variantes
  - Cast expl√≠cito para evitar BigInt serialization errors
- **Formato de respuesta unificado**:
  - Conversi√≥n autom√°tica de Decimal a Number en respuestas
  - Schema de Swagger actualizado con tipo 'number' para precios
  - Consistencia total entre findAll y findById

üîÑ **En desarrollo**:
- Paginaci√≥n para productos, clientes, proveedores

## Arquitectura Multi-Tenant

### Principio Fundamental
**TODAS las tablas (excepto `users`) incluyen `user_id` como clave for√°nea** para garantizar que cada tenant (usuario) solo pueda acceder a sus propios datos.

### Implementaci√≥n de Seguridad Multi-Tenant
```sql
-- Ejemplo de query seguro que siempre incluye user_id
SELECT * FROM products WHERE user_id = :current_user_id AND id = :product_id;

-- Las relaciones tambi√©n respetan el tenant
SELECT p.*, c.name as category_name 
FROM products p 
JOIN categories c ON c.id = p.category_id 
WHERE p.user_id = :current_user_id AND c.user_id = :current_user_id;
```

### Constraints Multi-Tenant
Todas las tablas tienen constraints que aseguran que las referencias pertenezcan al mismo usuario:

```sql
-- Ejemplo en product_variants
CONSTRAINT same_user_check CHECK (
  product_id IN (SELECT id FROM products WHERE user_id = NEW.user_id)
)
```

### Modelo de Datos Multi-Tenant
La aplicaci√≥n utiliza arquitectura **multi-tenant** donde cada usuario (tenant) tiene datos completamente aislados. **Todas las tablas incluyen `user_id`** como clave for√°nea para garantizar el aislamiento de datos.

#### Beneficios:
- ‚úÖ **Completo aislamiento de datos**: Cada usuario solo ve sus propios datos
- ‚úÖ **Escalable para miles de usuarios**: Arquitectura preparada para crecer
- ‚úÖ **Seguridad a nivel de base de datos**: user_id en todas las tablas previene acceso cruzado
- ‚úÖ **Integridad referencial**: Todas las relaciones respetan el tenant (user_id)
- ‚úÖ **Queries autom√°ticamente filtradas**: Siempre se incluye user_id en las consultas

### Estructura de Tablas

#### 1. Users (Usuarios)
```javascript
{
  id: Integer (PK, Auto-increment)
  email: String (√önico, Requerido)
  password_hash: String (Requerido)
  first_name: String (Requerido)
  last_name: String (Requerido)
  business_name: String (Opcional)
  is_active: Boolean (Default: true)
  email_verified: Boolean (Default: false)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

#### 2. Customers (Clientes)
```javascript
{
  id: Integer (PK, Auto-increment)
  user_id: Integer (FK -> users.id, Requerido)
  first_name: String (Requerido)
  last_name: String (Requerido)
  company: String (Opcional)
  phone: String (Opcional)
  email: String (Requerido)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Constraint √∫nico por usuario
  UNIQUE(user_id, email)
}
```

#### 3. Suppliers (Proveedores)
```javascript
{
  id: Integer (PK, Auto-increment)
  user_id: Integer (FK -> users.id, Requerido)
  first_name: String (Requerido)
  last_name: String (Requerido)
  company: String (Opcional)
  phone: String (Opcional)
  email: String (Requerido)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Constraint √∫nico por usuario
  UNIQUE(user_id, email)
}
```

#### 4. Categories (Categor√≠as) - Auto-referencial
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Requerido)
  name: String (Requerido)
  description: String (Opcional)
  parent_id: Integer (FK -> categories.id, Opcional)
  level: Integer (Default: 0, 0=ra√≠z, 1=subcategor√≠a, etc.)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

**Ejemplo de jerarqu√≠a:**
```
id=1, name="Suministros para Cerveza", parent_id=null, level=0
id=2, name="L√∫pulos", parent_id=1, level=1
id=3, name="L√∫pulos Americanos", parent_id=2, level=2
id=4, name="Maltas", parent_id=1, level=1
```

#### 5. Products (Productos)
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Requerido)
  name: String (Requerido)
  description: String (Opcional)
  selling_price: Decimal (Requerido) // Precio de venta - @db.Decimal(10, 2)
  category_id: Integer (FK -> categories.id)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)
}
```

#### 6. Product_Variants (Variantes de Producto)
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Requerido)
  product_id: Integer (FK -> products.id)
  variant_name: String (Requerido) // "Default" para productos sin variantes
  is_default: Boolean (Default: false) // Identificador confiable de variante default
  selling_price_modifier: Decimal (Default: 0) // +/- sobre selling_price - @db.Decimal(10, 2)
  stock: Integer (Default: 0) // √öNICO lugar donde se maneja stock
  attributes: Json (Opcional) // Atributos personalizados
  min_stock_alert: Integer (Default: 0) // Alerta de stock m√≠nimo
  enable_stock_alerts: Boolean (Default: true)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Nota: El constraint √∫nico para is_default se debe implementar a nivel de aplicaci√≥n
  // ya que PostgreSQL no soporta partial unique constraints con Prisma
}
```

**Casos de uso**:
- **Producto simple**: variant_name = "Default", maneja stock del producto
- **Producto con variantes**: Cada variante (talle, color, etc.) con stock independiente

#### 7. Variant_Suppliers (Proveedores por Variante)
```javascript
{
  id: Integer (PK)
  user_id: Integer (FK -> users.id, Requerido)
  variant_id: Integer (FK -> product_variants.id)
  supplier_id: Integer (FK -> suppliers.id)
  purchase_price: Decimal (Requerido) // Precio de compra - @db.Decimal(10, 2)
  is_primary_supplier: Boolean (Default: false)
  created_at: DateTime (Auto)
  updated_at: DateTime (Auto)

  // Constraint √∫nico: un proveedor por variante por usuario
  UNIQUE(user_id, variant_id, supplier_id)
}
```

## Decisiones de Dise√±o Importantes

### 1. Tablas Separadas para Clientes y Proveedores
**Decisi√≥n**: Crear tablas separadas `customers` y `suppliers` con estructura id√©ntica.

**Beneficios**:
- ‚úÖ Clara separaci√≥n de responsabilidades
- ‚úÖ Identificaci√≥n inmediata del rol del contacto
- ‚úÖ Permite l√≥gica de negocio diferente en el futuro
- ‚úÖ Escalabilidad para agregar campos espec√≠ficos

### 2. Control de Stock Solo en Variantes
**Decisi√≥n**: El stock se maneja √∫nicamente a nivel de variantes de producto.

**Implementaci√≥n**:
- **Productos SIN variantes**: Se crea autom√°ticamente una **variante DEFAULT**
- **Productos CON variantes**: Cada variante maneja su propio stock
- La variante default permite definir stock y stock m√≠nimo para productos simples

**Rationale**:
- Consistencia: toda la l√≥gica de stock est√° centralizada en `product_variants`
- Flexibilidad: permite evolucionar de producto simple a producto con variantes
- Simplicidad: un solo lugar para consultar stock independientemente del tipo de producto

### 3. Jerarqu√≠a de Categor√≠as Auto-referencial
**Decisi√≥n**: Usar tabla auto-referencial para categor√≠as con m√∫ltiples niveles.

**Beneficios**:
- ‚úÖ Flexibilidad completa en la estructura
- ‚úÖ Soporte para categor√≠as anidadas ilimitadas
- ‚úÖ F√°cil navegaci√≥n y organizaci√≥n

### 4. M√∫ltiples Proveedores por Variante
**Decisi√≥n**: Permitir m√∫ltiples proveedores por variante con precios diferentes.

**Beneficios**:
- ‚úÖ Comparaci√≥n de precios
- ‚úÖ Proveedores de respaldo
- ‚úÖ Optimizaci√≥n de costos

### 5. Autenticaci√≥n y Autorizaci√≥n
**Decisi√≥n**: Implementaci√≥n completa de JWT con protecci√≥n en todas las rutas.

**Implementaci√≥n**:
- **Rutas p√∫blicas**: Solo `POST /auth/login` y `POST /auth/register`
- **Rutas protegidas**: Todas las dem√°s (incluyendo update de usuario)
- **Middleware**: Extracci√≥n autom√°tica de user_id del token JWT
- **Seguridad multi-tenant**: user_id siempre validado en cada operaci√≥n

### 6. Query Optimization para findAll Products
**Decisi√≥n**: Usar raw SQL con JSON aggregation para m√°ximo rendimiento.

**Implementaci√≥n**:
- Raw SQL query para findAll (performance cr√≠tica con muchos productos)
- Prisma para findById (menos cr√≠tico, m√°s legible)
- Formato consistente entre ambos endpoints
- Cast expl√≠cito para evitar BigInt serialization errors
- JSON aggregation para incluir variantes en una sola query

**Benefits**:
- ‚úÖ **Performance**: Una sola query vs m√∫ltiples roundtrips
- ‚úÖ **Consistencia**: Mismo formato de respuesta en findAll y findById
- ‚úÖ **Escalabilidad**: Optimizado para manejar grandes vol√∫menes de productos
- ‚úÖ **Mantenibilidad**: Estructura clara y documentada

### 7. Formato de Respuesta Unificado para Precios
**Decisi√≥n**: Convertir todos los campos Decimal a Number en las respuestas de la API.

**Implementaci√≥n**:
- Middleware/utilidad para convertir `selling_price`, `selling_price_modifier`, `purchase_price` de string a number
- Schema de Swagger actualizado con tipo 'number' para todos los precios
- Consistencia total entre base de datos (Decimal) y API (Number)

**Rationale**:
- ‚úÖ **UX mejorada**: Frontend recibe n√∫meros directamente
- ‚úÖ **Precisi√≥n mantenida**: Base de datos sigue usando Decimal
- ‚úÖ **Consistencia**: Todos los endpoints devuelven el mismo formato
- ‚úÖ **Compatibilidad**: Funciona perfectamente con JSON y JavaScript

## L√≥gica de Negocio: Productos y Variantes

### Flujo para Productos Sin Variantes
1. **Creaci√≥n del producto**: Se crea normalmente
2. **Variante autom√°tica**: El sistema crea una variante con:
   - `variant_name = "Default"`
   - `selling_price_modifier = 0`
   - `is_default = true`
   - `stock` y `min_stock_alert` definidos por el usuario (default 0)
3. **Gesti√≥n de stock**: Todo el stock se maneja en la variante default

### Flujo para Productos Con Variantes
1. **Creaci√≥n del producto**: Se crea normalmente
2. **Variantes personalizadas**: El usuario crea variantes espec√≠ficas:
   - Ejemplo: "Talle S", "Talle M", "Talle L"
   - Cada una con `is_default = false`
   - Stock y alertas independientes (stock default 0)
3. **Stock distribuido**: Cada variante maneja su propio inventario

### C√°lculo de has_variants en Frontend
**Decisi√≥n**: Eliminar `has_variants` del backend y calcularlo en el cliente.

```javascript
// En el frontend
const hasVariants = product.variants.some(variant => !variant.is_default);
```

**Ventajas**:
- ‚úÖ Query m√°s simple y r√°pida
- ‚úÖ Menos redundancia de datos
- ‚úÖ L√≥gica trivial f√°cil de implementar en cliente

### Formato de Respuesta Unificado

Tanto `findAll` como `findById` devuelven el mismo formato con **variante default siempre incluida**:

#### Producto CON variantes personalizadas:
```json
{
    "id": 12,
    "name": "Product1",
    "selling_price": 100.00,
    "description": null,
    "category": {
        "id": 4,
        "name": "Categoria1"
    },
    "created_at": "2025-08-12T22:01:33.012Z",
    "updated_at": "2025-08-12T22:01:33.012Z",
    "variants": [
        {
            "id": 11,
            "variant_name": "Talle S",
            "stock": 25,
            "selling_price_modifier": 0.00,
            "min_stock_alert": 5,
            "enable_stock_alerts": true,
            "is_default": false,
            "attributes": null
        },
        {
            "id": 12,
            "variant_name": "Talle M", 
            "stock": 1,
            "selling_price_modifier": 10.00,
            "min_stock_alert": 3,
            "enable_stock_alerts": true,
            "is_default": false,
            "attributes": null
        }
    ],
    "total_stock": 26
}
```

#### Producto SIN variantes personalizadas (solo default):
```json
{
    "id": 15,
    "name": "Product Simple",
    "selling_price": 50.00,
    "description": null,
    "category": {
        "id": 4,
        "name": "Categoria1"
    },
    "created_at": "2025-08-12T22:01:33.012Z",
    "updated_at": "2025-08-12T22:01:33.012Z",
    "variants": [
        {
            "id": 20,
            "variant_name": "Default",
            "stock": 100,
            "selling_price_modifier": 0.00,
            "min_stock_alert": 10,
            "enable_stock_alerts": true,
            "is_default": true,
            "attributes": null
        }
    ],
    "total_stock": 100
}
```

### Ventajas de esta Aproximaci√≥n
‚úÖ **Consistencia absoluta**: Siempre consultar stock en `product_variants`, incluso para productos "simples"
‚úÖ **Escalabilidad**: F√°cil migraci√≥n de producto simple a producto con variantes
‚úÖ **Flexibilidad**: Diferentes precios, stock y alertas por variante
‚úÖ **Simplicidad en queries**: Un solo lugar para obtener informaci√≥n de stock
‚úÖ **Formato unificado**: Misma estructura en todos los endpoints
‚úÖ **L√≥gica centralizada**: No hay casos especiales para productos "sin variantes"

### Ejemplo Pr√°ctico
```sql
-- Obtener stock total de un producto (con o sin variantes)
SELECT SUM(pv.stock) as total_stock
FROM product_variants pv 
WHERE pv.product_id = :product_id AND pv.user_id = :user_id;

-- Obtener productos con stock bajo
SELECT p.name, pv.variant_name, pv.stock, pv.min_stock_alert
FROM products p
JOIN product_variants pv ON p.id = pv.product_id
WHERE pv.stock <= pv.min_stock_alert 
  AND pv.enable_stock_alerts = true
  AND p.user_id = :user_id;

-- Determinar si un producto tiene variantes personalizadas
SELECT p.*, 
       CASE WHEN EXISTS(
         SELECT 1 FROM product_variants pv 
         WHERE pv.product_id = p.id AND pv.is_default = false
       ) THEN true ELSE false END as has_custom_variants
FROM products p 
WHERE p.user_id = :user_id;
```

## Funcionalidades Principales

### Gesti√≥n de Usuarios
- Registro y autenticaci√≥n con JWT
- Verificaci√≥n de email
- Gesti√≥n de perfil de empresa
- Todas las rutas protegidas excepto login/register

### Gesti√≥n de Contactos
- **Clientes**: Gesti√≥n completa con informaci√≥n de contacto y empresa
- **Proveedores**: Gesti√≥n completa con informaci√≥n de contacto y empresa
- Aislamiento de datos por usuario

### Gesti√≥n de Inventario
- **Categor√≠as**: Jerarqu√≠a flexible multi-nivel
- **Productos**: Informaci√≥n b√°sica y precio de venta
- **Variantes**: Control detallado de stock, precios y atributos
  - **Variante Default**: Autom√°tica para productos sin variantes personalizadas
  - **Variantes Personalizadas**: Para productos con m√∫ltiples opciones
- **Stock Centralizado**: Toda la gesti√≥n de inventario en `product_variants`
- **Alertas de Stock**: Configurables por variante (incluyendo default)

### Gesti√≥n de Proveedores
- M√∫ltiples proveedores por producto/variante
- Precios de compra diferenciados
- Proveedor principal por variante

## Tecnolog√≠as Utilizadas

### Backend
- **Node.js** con **Express.js**
- **Prisma ORM** para manejo de base de datos
- **PostgreSQL** como base de datos
- **express-validator** para validaciones
- **JWT** para autenticaci√≥n y autorizaci√≥n
- Rutas CRUD completas implementadas
- **Raw SQL queries** para optimizaci√≥n de performance en listados

### Base de Datos
- **PostgreSQL** con esquema multi-tenant
- Relaciones complejas con integridad referencial
- Constraints √∫nicos por usuario
- JSON aggregation para consultas optimizadas

## Pr√≥ximos Pasos Sugeridos

### Backend (API)
1. **Pendiente Inmediato**
   - **Paginaci√≥n** (en desarrollo)
     - Implementar para productos, clientes, proveedores
     - Par√°metros: `?page=1&limit=20`
     - Response con metadata de paginaci√≥n

2. **Funcionalidades Avanzadas**
   - Sistema de alertas de stock bajo
   - Reportes de inventario
   - Historial de movimientos de stock
   - API para b√∫squedas y filtros

3. **Optimizaciones**
   - √çndices de base de datos
   - Cach√© para consultas frecuentes
   - Monitoring de performance

### Casos de uso espec√≠ficos:
- **Asignar proveedor principal**: Autom√°ticamente des-marcar otros como principales
- **Comparar precios**: Obtener todos los proveedores de una variante con sus precios
- **Gesti√≥n de proveedores**: Ver todas las variantes que suministra un proveedor
- **Actualizaci√≥n restrictiva**: Solo precio y flag principal pueden modificarse
- **Cambio de proveedor/variante**: Requiere eliminar relaci√≥n existente y crear nueva

### L√≥gica de Negocio Variant-Suppliers
```javascript
// ‚úÖ Permitido en UPDATE
{
  purchase_price: Decimal, // Nuevo precio de compra
  is_primary_supplier: Boolean // Cambiar si es proveedor principal
}

// ‚ùå NO permitido en UPDATE - Requiere DELETE + POST
{
  variant_id: Integer, // Cambiar variante
  supplier_id: Integer, // Cambiar proveedor
  user_id: Integer // Siempre del usuario autenticado
}
```

**Raz√≥n**: Mantener integridad de la relaci√≥n y evitar confusi√≥n en hist√≥ricos de precios.

### Desestructuraci√≥n para Updates Parciales
```javascript
// JavaScript permite desestructuraci√≥n sin errores
const { purchase_price, is_primary_supplier } = req.body;

// Si alguna propiedad no existe, ser√° undefined
// purchase_price = undefined (si no se env√≠a)
// is_primary_supplier = true (si se env√≠a)

// Construir objeto de actualizaci√≥n din√°mico
const updateData = {};
if (purchase_price !== undefined) updateData.purchase_price = purchase_price;
if (is_primary_supplier !== undefined) updateData.is_primary_supplier = is_primary_supplier;
```

### Frontend
1. **Interfaz de Usuario**
   - Dashboard principal
   - Gesti√≥n de inventario
   - Gesti√≥n de contactos
   - Reportes y anal√≠ticas

2. **Experiencia de Usuario**
   - Dise√±o responsive
   - Interfaz intuitiva
   - Notificaciones en tiempo real

### Despliegue
1. **Infraestructura**
   - Configuraci√≥n de servidor
   - Base de datos en producci√≥n
   - Variables de entorno
   - Monitoreo y logs

## Notas T√©cnicas Multi-Tenant

### Prisma Schema
- Generador configurado para output personalizado
- **Todas las relaciones incluyen user_id** para aislamiento de datos
- Constraints √∫nicos combinados con user_id (ej: `@@unique([user_id, email])`)
- Cascading deletes que respetan el tenant

### Validaciones y Seguridad
- express-validator implementado en todas las rutas
- **Validaci√≥n autom√°tica de user_id** en todas las operaciones
- Middleware para verificar ownership de recursos
- Sanitizaci√≥n de par√°metros con control de tenant
- **Limpieza de datos**: Prevenci√≥n de modificaci√≥n de campos protegidos
  - Validaci√≥n de campos permitidos en middleware (express-validator)
  - Limpieza adicional en servicios para campos sensibles
  - Protecci√≥n contra modificaci√≥n de: `user_id`, `id`, `createdAt`, `updatedAt`
  - **Nota**: `updatedAt` se maneja autom√°ticamente por Prisma (`@updatedAt`)

### Seguridad Multi-Tenant
- **Aislamiento garantizado**: user_id en todas las tablas
- **Queries autom√°ticamente filtradas** por tenant
- **Relaciones verificadas**: constraints que previenen referencias cruzadas
- **JWT implementado**: Middleware de autenticaci√≥n con extracci√≥n de user_id del token

### Performance Optimizations
- **Raw SQL para listados**: findAll products optimizado con raw queries
- **Prisma para operaciones individuales**: findById mantiene sintaxis ORM
- **JSON aggregation**: Variantes incluidas en una sola query
- **Cast expl√≠cito**: Evita errores de serializaci√≥n BigInt
- **Conversi√≥n autom√°tica**: Decimal a Number en respuestas
- **√çndices**: Configurados para queries multi-tenant frecuentes

---

**√öltima actualizaci√≥n**: Agosto 2025
**Estado del proyecto**: API base completada con autenticaci√≥n JWT, variant-suppliers implementado, queries optimizadas, formato de respuesta unificado con conversi√≥n autom√°tica de precios, paginaci√≥n en desarrollo, listo para funcionalidades avanzadas y frontend